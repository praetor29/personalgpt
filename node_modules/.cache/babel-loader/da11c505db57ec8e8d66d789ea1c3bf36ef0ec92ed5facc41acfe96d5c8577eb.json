{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolveLocalizedStringFactory = void 0;\nconst assert_1 = require(\"tsafe/assert\");\nconst is_1 = require(\"tsafe/is\");\nconst noUndefined_1 = require(\"tsafe/noUndefined\");\n/** Note react as dependency injection */\nfunction createResolveLocalizedStringFactory(params) {\n  const {\n    createJsxElement\n  } = params;\n  function createResolveLocalizedString(params) {\n    const {\n      currentLanguage,\n      fallbackLanguage,\n      labelWhenMismatchingLanguage = false\n    } = params;\n    function resolveLocalizedStringDetailed(localizedString) {\n      var _a;\n      if (typeof localizedString === \"string\") {\n        const {\n          ifStringAssumeLanguage\n        } = typeof labelWhenMismatchingLanguage === \"object\" ? labelWhenMismatchingLanguage : {\n          ifStringAssumeLanguage: fallbackLanguage\n        };\n        if (currentLanguage === ifStringAssumeLanguage) {\n          return {\n            \"str\": localizedString,\n            \"langAttrValue\": undefined\n          };\n        }\n        return {\n          \"str\": localizedString,\n          \"langAttrValue\": ifStringAssumeLanguage\n        };\n      }\n      localizedString = (0, noUndefined_1.noUndefined)(localizedString);\n      {\n        const text = localizedString[currentLanguage];\n        if (typeof text === \"string\") {\n          return {\n            \"str\": text,\n            \"langAttrValue\": undefined\n          };\n        }\n      }\n      {\n        const text = localizedString[fallbackLanguage];\n        if (typeof text === \"string\") {\n          return {\n            \"str\": text,\n            \"langAttrValue\": fallbackLanguage\n          };\n        }\n      }\n      const [lang, text] = (_a = Object.entries(localizedString)[0]) !== null && _a !== void 0 ? _a : [];\n      (0, assert_1.assert)(typeof text === \"string\", \"Must contain at least one value\");\n      (0, assert_1.assert)((0, is_1.is)(lang));\n      return {\n        \"str\": text,\n        \"langAttrValue\": lang\n      };\n    }\n    function resolveLocalizedString(localizedString) {\n      const {\n        str,\n        langAttrValue\n      } = resolveLocalizedStringDetailed(localizedString);\n      return labelWhenMismatchingLanguage !== false ? createJsxElement({\n        \"text\": str,\n        \"lang\": langAttrValue\n      }) : str;\n    }\n    return {\n      resolveLocalizedString,\n      resolveLocalizedStringDetailed\n    };\n  }\n  return {\n    createResolveLocalizedString\n  };\n}\nexports.createResolveLocalizedStringFactory = createResolveLocalizedStringFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","createResolveLocalizedStringFactory","assert_1","require","is_1","noUndefined_1","params","createJsxElement","createResolveLocalizedString","currentLanguage","fallbackLanguage","labelWhenMismatchingLanguage","resolveLocalizedStringDetailed","localizedString","_a","ifStringAssumeLanguage","undefined","noUndefined","text","lang","entries","assert","is","resolveLocalizedString","str","langAttrValue"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/i18nifty-virtual-f94293219d/3/AppData/Local/Yarn/Berry/cache/i18nifty-npm-1.6.2-79bdda185a-10c0.zip/node_modules/i18nifty/LocalizedString/LocalizedString.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createResolveLocalizedStringFactory = void 0;\nconst assert_1 = require(\"tsafe/assert\");\nconst is_1 = require(\"tsafe/is\");\nconst noUndefined_1 = require(\"tsafe/noUndefined\");\n/** Note react as dependency injection */\nfunction createResolveLocalizedStringFactory(params) {\n    const { createJsxElement } = params;\n    function createResolveLocalizedString(params) {\n        const { currentLanguage, fallbackLanguage, labelWhenMismatchingLanguage = false } = params;\n        function resolveLocalizedStringDetailed(localizedString) {\n            var _a;\n            if (typeof localizedString === \"string\") {\n                const { ifStringAssumeLanguage } = typeof labelWhenMismatchingLanguage === \"object\"\n                    ? labelWhenMismatchingLanguage\n                    : { ifStringAssumeLanguage: fallbackLanguage };\n                if (currentLanguage === ifStringAssumeLanguage) {\n                    return {\n                        \"str\": localizedString,\n                        \"langAttrValue\": undefined\n                    };\n                }\n                return {\n                    \"str\": localizedString,\n                    \"langAttrValue\": ifStringAssumeLanguage\n                };\n            }\n            localizedString = (0, noUndefined_1.noUndefined)(localizedString);\n            {\n                const text = localizedString[currentLanguage];\n                if (typeof text === \"string\") {\n                    return {\n                        \"str\": text,\n                        \"langAttrValue\": undefined\n                    };\n                }\n            }\n            {\n                const text = localizedString[fallbackLanguage];\n                if (typeof text === \"string\") {\n                    return {\n                        \"str\": text,\n                        \"langAttrValue\": fallbackLanguage\n                    };\n                }\n            }\n            const [lang, text] = (_a = Object.entries(localizedString)[0]) !== null && _a !== void 0 ? _a : [];\n            (0, assert_1.assert)(typeof text === \"string\", \"Must contain at least one value\");\n            (0, assert_1.assert)((0, is_1.is)(lang));\n            return {\n                \"str\": text,\n                \"langAttrValue\": lang\n            };\n        }\n        function resolveLocalizedString(localizedString) {\n            const { str, langAttrValue } = resolveLocalizedStringDetailed(localizedString);\n            return labelWhenMismatchingLanguage !== false\n                ? createJsxElement({ \"text\": str, \"lang\": langAttrValue })\n                : str;\n        }\n        return { resolveLocalizedString, resolveLocalizedStringDetailed };\n    }\n    return { createResolveLocalizedString };\n}\nexports.createResolveLocalizedStringFactory = createResolveLocalizedStringFactory;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,mCAAmC,GAAG,KAAK,CAAC;AACpD,MAAMC,QAAQ,GAAGC,OAAO,CAAC,cAAc,CAAC;AACxC,MAAMC,IAAI,GAAGD,OAAO,CAAC,UAAU,CAAC;AAChC,MAAME,aAAa,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAClD;AACA,SAASF,mCAAmCA,CAACK,MAAM,EAAE;EACjD,MAAM;IAAEC;EAAiB,CAAC,GAAGD,MAAM;EACnC,SAASE,4BAA4BA,CAACF,MAAM,EAAE;IAC1C,MAAM;MAAEG,eAAe;MAAEC,gBAAgB;MAAEC,4BAA4B,GAAG;IAAM,CAAC,GAAGL,MAAM;IAC1F,SAASM,8BAA8BA,CAACC,eAAe,EAAE;MACrD,IAAIC,EAAE;MACN,IAAI,OAAOD,eAAe,KAAK,QAAQ,EAAE;QACrC,MAAM;UAAEE;QAAuB,CAAC,GAAG,OAAOJ,4BAA4B,KAAK,QAAQ,GAC7EA,4BAA4B,GAC5B;UAAEI,sBAAsB,EAAEL;QAAiB,CAAC;QAClD,IAAID,eAAe,KAAKM,sBAAsB,EAAE;UAC5C,OAAO;YACH,KAAK,EAAEF,eAAe;YACtB,eAAe,EAAEG;UACrB,CAAC;QACL;QACA,OAAO;UACH,KAAK,EAAEH,eAAe;UACtB,eAAe,EAAEE;QACrB,CAAC;MACL;MACAF,eAAe,GAAG,CAAC,CAAC,EAAER,aAAa,CAACY,WAAW,EAAEJ,eAAe,CAAC;MACjE;QACI,MAAMK,IAAI,GAAGL,eAAe,CAACJ,eAAe,CAAC;QAC7C,IAAI,OAAOS,IAAI,KAAK,QAAQ,EAAE;UAC1B,OAAO;YACH,KAAK,EAAEA,IAAI;YACX,eAAe,EAAEF;UACrB,CAAC;QACL;MACJ;MACA;QACI,MAAME,IAAI,GAAGL,eAAe,CAACH,gBAAgB,CAAC;QAC9C,IAAI,OAAOQ,IAAI,KAAK,QAAQ,EAAE;UAC1B,OAAO;YACH,KAAK,EAAEA,IAAI;YACX,eAAe,EAAER;UACrB,CAAC;QACL;MACJ;MACA,MAAM,CAACS,IAAI,EAAED,IAAI,CAAC,GAAG,CAACJ,EAAE,GAAGjB,MAAM,CAACuB,OAAO,CAACP,eAAe,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;MAClG,CAAC,CAAC,EAAEZ,QAAQ,CAACmB,MAAM,EAAE,OAAOH,IAAI,KAAK,QAAQ,EAAE,iCAAiC,CAAC;MACjF,CAAC,CAAC,EAAEhB,QAAQ,CAACmB,MAAM,EAAE,CAAC,CAAC,EAAEjB,IAAI,CAACkB,EAAE,EAAEH,IAAI,CAAC,CAAC;MACxC,OAAO;QACH,KAAK,EAAED,IAAI;QACX,eAAe,EAAEC;MACrB,CAAC;IACL;IACA,SAASI,sBAAsBA,CAACV,eAAe,EAAE;MAC7C,MAAM;QAAEW,GAAG;QAAEC;MAAc,CAAC,GAAGb,8BAA8B,CAACC,eAAe,CAAC;MAC9E,OAAOF,4BAA4B,KAAK,KAAK,GACvCJ,gBAAgB,CAAC;QAAE,MAAM,EAAEiB,GAAG;QAAE,MAAM,EAAEC;MAAc,CAAC,CAAC,GACxDD,GAAG;IACb;IACA,OAAO;MAAED,sBAAsB;MAAEX;IAA+B,CAAC;EACrE;EACA,OAAO;IAAEJ;EAA6B,CAAC;AAC3C;AACAT,OAAO,CAACE,mCAAmC,GAAGA,mCAAmC"},"metadata":{},"sourceType":"script","externalDependencies":[]}