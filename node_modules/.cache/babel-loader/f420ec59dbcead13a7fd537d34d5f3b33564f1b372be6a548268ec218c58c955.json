{"ast":null,"code":"import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\nfunction isProjecting(visualElement) {\n  var isEnabled = visualElement.projection.isEnabled;\n  return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n  var parent = visualElement.parent;\n  if (parent) collectProjectingAncestors(parent, ancestors);\n  if (isProjecting(visualElement)) ancestors.push(visualElement);\n  return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n  var addChild = function (child) {\n    if (isProjecting(child)) children.push(child);\n    child.children.forEach(addChild);\n  };\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync.update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nexport { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };","map":{"version":3,"names":["sync","copyAxisBox","compareByDepth","isProjecting","visualElement","isEnabled","projection","shouldResetTransform","collectProjectingAncestors","ancestors","parent","push","collectProjectingChildren","children","addChild","child","forEach","sort","updateLayoutMeasurement","layoutState","getLayoutState","notifyBeforeLayoutMeasure","layout","isHydrated","measureViewportBox","layoutCorrected","notifyLayoutMeasure","prevViewportBox","update","rebaseProjectionTarget","snapshotViewportBox"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/render/dom/projection/utils.js"],"sourcesContent":["import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nexport { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;AAC5B,SAASC,WAAW,QAAQ,kCAAkC;AAC9D,SAASC,cAAc,QAAQ,iCAAiC;AAEhE,SAASC,YAAYA,CAACC,aAAa,EAAE;EACjC,IAAIC,SAAS,GAAGD,aAAa,CAACE,UAAU,CAACD,SAAS;EAClD,OAAOA,SAAS,IAAID,aAAa,CAACG,oBAAoB,CAAC,CAAC;AAC5D;AACA,SAASC,0BAA0BA,CAACJ,aAAa,EAAEK,SAAS,EAAE;EAC1D,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,EAAE;EAAE;EAC5C,IAAIC,MAAM,GAAGN,aAAa,CAACM,MAAM;EACjC,IAAIA,MAAM,EACNF,0BAA0B,CAACE,MAAM,EAAED,SAAS,CAAC;EACjD,IAAIN,YAAY,CAACC,aAAa,CAAC,EAC3BK,SAAS,CAACE,IAAI,CAACP,aAAa,CAAC;EACjC,OAAOK,SAAS;AACpB;AACA,SAASG,yBAAyBA,CAACR,aAAa,EAAE;EAC9C,IAAIS,QAAQ,GAAG,EAAE;EACjB,IAAIC,QAAQ,GAAG,SAAAA,CAAUC,KAAK,EAAE;IAC5B,IAAIZ,YAAY,CAACY,KAAK,CAAC,EACnBF,QAAQ,CAACF,IAAI,CAACI,KAAK,CAAC;IACxBA,KAAK,CAACF,QAAQ,CAACG,OAAO,CAACF,QAAQ,CAAC;EACpC,CAAC;EACDV,aAAa,CAACS,QAAQ,CAACG,OAAO,CAACF,QAAQ,CAAC;EACxC,OAAOD,QAAQ,CAACI,IAAI,CAACf,cAAc,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,SAASgB,uBAAuBA,CAACd,aAAa,EAAE;EAC5C,IAAIA,aAAa,CAACG,oBAAoB,CAAC,CAAC,EACpC;EACJ,IAAIY,WAAW,GAAGf,aAAa,CAACgB,cAAc,CAAC,CAAC;EAChDhB,aAAa,CAACiB,yBAAyB,CAACF,WAAW,CAACG,MAAM,CAAC;EAC3DH,WAAW,CAACI,UAAU,GAAG,IAAI;EAC7BJ,WAAW,CAACG,MAAM,GAAGlB,aAAa,CAACoB,kBAAkB,CAAC,CAAC;EACvDL,WAAW,CAACM,eAAe,GAAGxB,WAAW,CAACkB,WAAW,CAACG,MAAM,CAAC;EAC7DlB,aAAa,CAACsB,mBAAmB,CAACP,WAAW,CAACG,MAAM,EAAElB,aAAa,CAACuB,eAAe,IAAIR,WAAW,CAACG,MAAM,CAAC;EAC1GtB,IAAI,CAAC4B,MAAM,CAAC,YAAY;IAAE,OAAOxB,aAAa,CAACyB,sBAAsB,CAAC,CAAC;EAAE,CAAC,CAAC;AAC/E;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAC1B,aAAa,EAAE;EACxC,IAAIA,aAAa,CAACG,oBAAoB,CAAC,CAAC,EACpC;EACJH,aAAa,CAACuB,eAAe,GAAGvB,aAAa,CAACoB,kBAAkB,CAAC,KAAK,CAAC;EACvE;AACJ;AACA;AACA;EACIpB,aAAa,CAACyB,sBAAsB,CAAC,KAAK,EAAEzB,aAAa,CAACuB,eAAe,CAAC;AAC9E;AAEA,SAASnB,0BAA0B,EAAEI,yBAAyB,EAAEkB,mBAAmB,EAAEZ,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}