{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePropsFromArgs = exports.matchAll = void 0;\nvar id_1 = require(\"tsafe/id\");\nvar compose_1 = require(\"./util/compose\");\nvar typeGuard_1 = require(\"tsafe/typeGuard\");\nfunction matchAll() {\n  return true;\n}\nexports.matchAll = matchAll;\nvar canBeOperator = function (p) {\n  return p !== undefined && (0, typeGuard_1.typeGuard)(p, true) && (typeof p === \"function\" || typeof p[0] === \"function\");\n};\nvar defaultParams = {\n  \"op\": matchAll,\n  \"ctx\": undefined,\n  \"timeout\": undefined,\n  \"callback\": undefined\n};\nfunction parsePropsFromArgs(inputs, methodName) {\n  switch (methodName) {\n    case \"pipe\":\n      {\n        //[]\n        //[undefined] ( not valid but user would expect it to work )\n        //[ ctx, ...op[] ]\n        //[ ...op[] ]\n        var getOpWrap = function (ops) {\n          return ops.length === 0 ? {} : {\n            \"op\": ops.length === 1 ? ops[0] : compose_1.compose.apply(void 0, __spreadArray([], __read(ops), false))\n          };\n        };\n        if (canBeOperator(inputs[0])) {\n          //[ ...op[] ]\n          return (0, id_1.id)(__assign(__assign({}, defaultParams), getOpWrap(inputs)));\n        } else {\n          //[]\n          //[ ctx, ...Operator.fλ[] ]\n          var _a = __read(inputs),\n            ctx = _a[0],\n            rest = _a.slice(1);\n          return (0, id_1.id)(__assign(__assign(__assign({}, defaultParams), ctx !== undefined ? {\n            ctx: ctx\n          } : {}), getOpWrap(rest)));\n        }\n      }\n      break;\n    case \"waitFor\":\n      {\n        //[ op, ctx, timeout ]\n        //[ op, ctx, undefined ]\n        //[ op, ctx ]\n        //[ op, timeout ]\n        //[ op, undefined ]\n        //[ ctx, timeout ]\n        //[ ctx, undefined ]\n        //[ op ]\n        //[ ctx ]\n        //[ timeout ]\n        //[ undefined ]\n        //[ callback ]\n        return parsePropsFromArgs(__spreadArray(__spreadArray([], __read(inputs.filter(function (value, index) {\n          return !(index === inputs.length - 1 && value === undefined);\n        })), false), [defaultParams.callback], false), \"attach*\");\n      }\n      break;\n    case \"attach*\":\n      {\n        //NOTE: when callback is undefined call has been forward from waitFor.\n        //[ op, ctx, timeout, callback ]\n        //[ op, ctx, timeout, undefined ]\n        //[ op, ctx, callback ]\n        //[ op, ctx, undefined ]\n        //[ op, timeout, callback ]\n        //[ op, timeout, undefined ]\n        //[ ctx, timeout, callback ]\n        //[ ctx, timeout, undefined ]\n        //[ op, callback ]\n        //[ op, undefined ]\n        //[ ctx, callback ]\n        //[ ctx, undefined ]\n        //[ timeout, callback ]\n        //[ timeout, undefined ]\n        //[ callback ]\n        //[ undefined ]\n        var n = inputs.length;\n        switch (n) {\n          case 4:\n            {\n              //[ op, ctx, timeout, callback ]\n              var _b = __read(inputs, 4),\n                p1 = _b[0],\n                p2 = _b[1],\n                p3 = _b[2],\n                p4 = _b[3];\n              return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                \"op\": p1,\n                \"ctx\": p2,\n                \"timeout\": p3,\n                \"callback\": p4\n              }));\n            }\n          case 3:\n            {\n              //[ op, ctx, callback ]\n              //[ op, timeout, callback ]\n              //[ ctx, timeout, callback ]\n              var _c = __read(inputs, 3),\n                p1 = _c[0],\n                p2 = _c[1],\n                p3 = _c[2];\n              if (typeof p2 === \"number\") {\n                //[ op, timeout, callback ]\n                //[ ctx, timeout, callback ]\n                var timeout = p2;\n                var callback = p3;\n                if (canBeOperator(p1)) {\n                  //[ op, timeout, callback ]\n                  return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                    timeout: timeout,\n                    callback: callback,\n                    \"op\": p1\n                  }));\n                } else {\n                  //[ ctx, timeout, callback ]\n                  return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                    timeout: timeout,\n                    callback: callback,\n                    \"ctx\": p1\n                  }));\n                }\n              } else {\n                //[ op, ctx, callback ]\n                return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                  \"op\": p1,\n                  \"ctx\": p2,\n                  \"callback\": p3\n                }));\n              }\n            }\n          case 2:\n            {\n              //[ op, callback ]\n              //[ ctx, callback ]\n              //[ timeout, callback ]\n              var _d = __read(inputs, 2),\n                p1 = _d[0],\n                p2 = _d[1];\n              if (typeof p1 === \"number\") {\n                //[ timeout, callback ]\n                return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                  \"timeout\": p1,\n                  \"callback\": p2\n                }));\n              } else {\n                //[ op, callback ]\n                //[ ctx, callback ]\n                var callback = p2;\n                if (canBeOperator(p1)) {\n                  return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                    callback: callback,\n                    \"op\": p1\n                  }));\n                } else {\n                  return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                    callback: callback,\n                    \"ctx\": p1\n                  }));\n                }\n              }\n            }\n          case 1:\n            {\n              //[ callback ]\n              var _e = __read(inputs, 1),\n                p = _e[0];\n              return (0, id_1.id)(__assign(__assign({}, defaultParams), {\n                \"callback\": p\n              }));\n            }\n          case 0:\n            {\n              return (0, id_1.id)(__assign({}, defaultParams));\n            }\n        }\n      }\n      break;\n  }\n}\nexports.parsePropsFromArgs = parsePropsFromArgs;","map":{"version":3,"names":["id_1","require","compose_1","typeGuard_1","matchAll","exports","canBeOperator","p","undefined","typeGuard","defaultParams","parsePropsFromArgs","inputs","methodName","getOpWrap","ops","length","compose","apply","__spreadArray","__read","id","__assign","_a","ctx","rest","slice","filter","value","index","callback","n","_b","p1","p2","p3","p4","_c","timeout","_d","_e"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\evt-npm-2.5.3-c2ac0365d2-10c0.zip\\node_modules\\evt\\src\\lib\\Evt.parsePropsFromArgs.ts"],"sourcesContent":["\nimport type { Operator } from \"./types/Operator\"\nimport { id } from \"tsafe/id\";\nimport { compose } from \"./util/compose\";\nimport { typeGuard } from \"tsafe/typeGuard\"\nimport type { CtxLike, Handler } from \"./types\";\n\nexport function matchAll() { return true; }\n\nconst canBeOperator = (p: undefined | CtxLike<any> | Operator<any, any>): boolean => {\n    return (\n        p !== undefined &&\n        typeGuard<Operator<any, any>>(p, true) &&\n        (\n            typeof p === \"function\" ||\n            typeof p[0] === \"function\"\n        )\n    );\n};\n\nconst defaultParams: Handler.PropsFromArgs<any, any> = {\n    \"op\": matchAll,\n    \"ctx\": undefined,\n    \"timeout\": undefined,\n    \"callback\": undefined\n};\n\nexport function parsePropsFromArgs<T>(\n    inputs: readonly any[],\n    methodName: \"waitFor\" | \"attach*\" | \"pipe\"\n): Handler.PropsFromArgs<T, any> {\n\n    type Out = Handler.PropsFromArgs<T, any>;\n\n    switch (methodName) {\n        case \"pipe\": {\n\n            //[]\n            //[undefined] ( not valid but user would expect it to work )\n            //[ ctx, ...op[] ]\n            //[ ...op[] ]\n\n            const getOpWrap = (ops: [Operator<T, any>, ...Operator<any, any>[]]) =>\n                ops.length === 0 ?\n                    {}\n                    :\n                    { \"op\": ops.length === 1 ? ops[0] : compose(...ops) }\n                ;\n\n            if (canBeOperator(inputs[0])) {\n\n                //[ ...op[] ]\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...getOpWrap(inputs as any)\n                });\n\n            } else {\n\n                //[]\n                //[ ctx, ...Operator.fλ[] ]\n\n                const [ctx, ...rest] = inputs;\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...(ctx !== undefined ? { ctx } : {}),\n                    ...getOpWrap(rest as any)\n                });\n\n            }\n\n\n        } break;\n\n        case \"waitFor\": {\n\n            //[ op, ctx, timeout ]\n            //[ op, ctx, undefined ]\n            //[ op, ctx ]\n            //[ op, timeout ]\n            //[ op, undefined ]\n            //[ ctx, timeout ]\n            //[ ctx, undefined ]\n            //[ op ]\n            //[ ctx ]\n            //[ timeout ]\n            //[ undefined ]\n            //[ callback ]\n\n            return parsePropsFromArgs(\n                [\n                    //If the last element is undefined, remove it.\n                    ...inputs.filter(\n                        (value, index) => !(\n                            index === inputs.length - 1 &&\n                            value === undefined\n                        )\n                    ),\n                    defaultParams.callback\n                ],\n                \"attach*\"\n            );\n\n        } break;\n        case \"attach*\": {\n\n            //NOTE: when callback is undefined call has been forward from waitFor.\n\n            //[ op, ctx, timeout, callback ]\n            //[ op, ctx, timeout, undefined ]\n            //[ op, ctx, callback ]\n            //[ op, ctx, undefined ]\n            //[ op, timeout, callback ]\n            //[ op, timeout, undefined ]\n            //[ ctx, timeout, callback ]\n            //[ ctx, timeout, undefined ]\n            //[ op, callback ]\n            //[ op, undefined ]\n            //[ ctx, callback ]\n            //[ ctx, undefined ]\n            //[ timeout, callback ]\n            //[ timeout, undefined ]\n            //[ callback ]\n            //[ undefined ]\n\n            const n = inputs.length as 4 | 3 | 2 | 1 | 0;\n\n            switch (n) {\n                case 4: {\n\n                    //[ op, ctx, timeout, callback ]\n                    const [p1, p2, p3, p4] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"op\": p1,\n                        \"ctx\": p2,\n                        \"timeout\": p3,\n                        \"callback\": p4\n                    });\n\n                }\n                case 3: {\n\n                    //[ op, ctx, callback ]\n                    //[ op, timeout, callback ]\n                    //[ ctx, timeout, callback ]\n                    const [p1, p2, p3] = inputs;\n                    if (typeof p2 === \"number\") {\n                        //[ op, timeout, callback ]\n                        //[ ctx, timeout, callback ]\n\n                        const timeout: Out[\"timeout\"] = p2;\n                        const callback: Out[\"callback\"] = p3;\n\n                        if (canBeOperator(p1)) {\n                            //[ op, timeout, callback ]\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n                            //[ ctx, timeout, callback ]\n\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    } else {\n                        //[ op, ctx, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"op\": p1,\n                            \"ctx\": p2,\n                            \"callback\": p3\n                        });\n\n                    }\n\n                }\n                case 2: {\n\n                    //[ op, callback ]\n                    //[ ctx, callback ]\n                    //[ timeout, callback ]\n                    const [p1, p2] = inputs;\n                    if (typeof p1 === \"number\") {\n                        //[ timeout, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"timeout\": p1,\n                            \"callback\": p2\n                        });\n                    } else {\n                        //[ op, callback ]\n                        //[ ctx, callback ]\n                        const callback: Out[\"callback\"] = p2;\n                        if (canBeOperator(p1)) {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    }\n\n                }\n                case 1: {\n\n                    //[ callback ]\n                    const [p] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"callback\": p\n                    });\n\n                }\n                case 0: {\n                    return id<Out>({ ...defaultParams });\n                }\n\n            }\n\n\n        } break;\n\n    }\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}