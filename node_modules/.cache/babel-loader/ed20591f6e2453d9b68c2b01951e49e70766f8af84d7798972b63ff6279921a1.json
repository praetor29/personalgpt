{"ast":null,"code":"import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { getValueTransition } from '../../../animation/utils/transitions.js';\nimport { motionValue } from '../../../value/index.js';\nfunction createCrossfader() {\n  /**\n   * The current state of the crossfade as a value between 0 and 1\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n  var prevOptions = __assign({}, options);\n  var leadState = {};\n  var followState = {};\n  /**\n   *\n   */\n  var isActive = false;\n  /**\n   *\n   */\n  var finalCrossfadeFrame = null;\n  /**\n   * Framestamp of the last frame we updated values at.\n   */\n  var prevUpdate = 0;\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n      follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n    var onUpdate = function () {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n    var onComplete = function () {\n      isActive = false;\n      /**\n       * If the crossfade animation is no longer active, flag a frame\n       * that we're still allowed to crossfade\n       */\n      finalCrossfadeFrame = getFrameData().timestamp;\n    };\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate(progress, target, __assign(__assign({}, transition), {\n      onUpdate: onUpdate,\n      onComplete: function () {\n        if (!hasUpdated) {\n          progress.set(target);\n          /**\n           * If we never ran an update, for instance if this was an instant transition, fire a\n           * simulated final frame to ensure the crossfade gets applied correctly.\n           */\n          sync.read(onComplete);\n        } else {\n          onComplete();\n        }\n        onUpdate();\n      }\n    }));\n  }\n  function updateCrossfade() {\n    var _a, _b;\n    /**\n     * We only want to compute the crossfade once per frame, so we\n     * compare the previous update framestamp with the current frame\n     * and early return if they're the same.\n     */\n    var timestamp = getFrameData().timestamp;\n    var lead = options.lead,\n      follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\n     * Merge each component's latest values into our crossfaded state\n     * before crossfading.\n     */\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\n     * Crossfade the opacity between the two components. This will result\n     * in a different opacity for each component.\n     */\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = mix(\n      /**\n       * If the follow child has been completely hidden we animate\n       * this opacity from its previous opacity, but otherwise from completely transparent.\n       */\n      follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n  return {\n    isActive: function () {\n      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      var initialProgress = 0;\n      if (!options.prevValues && !options.follow) {\n        /**\n         * If we're not coming from anywhere, start at the end of the animation.\n         */\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        /**\n         * If we're swapping follow/lead we can reverse the progress\n         */\n        initialProgress = 1 - progress.get();\n      }\n      progress.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\n   * We only want to mix the background color if there's a follow element\n   * that we're not crossfading opacity between. For instance with switch\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\n   * element being animated but also cuts down on the number of paints triggered\n   * for elements where opacity is doing that work for us.\n   */\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n     * We could probably create a mixer that runs at the start of the animation but\n     * the idea behind the crossfader is that it runs dynamically between two potentially\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\n     */\n    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nexport { createCrossfader };","map":{"version":3,"names":["__assign","sync","getFrameData","mix","progress","linear","mixColor","circOut","animate","getValueTransition","motionValue","createCrossfader","options","lead","undefined","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","leadState","followState","isActive","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","target","transition","hasUpdated","onUpdate","scheduleRender","onComplete","timestamp","set","read","updateCrossfade","_a","_b","latestLeadValues","getLatestValues","Object","assign","latestFollowValues","prevValues","p","get","leadTargetOpacity","opacity","followTargetOpacity","isVisible","easeCrossfadeIn","easeCrossfadeOut","mixValues","Boolean","fromLead","toLead","initialProgress","reset","stop","getCrossfadeState","element","setOptions","newOptions","compress","min","max","easing","borders","numBorders","length","hasFollowElement","i","borderLabel","followRadius","getRadius","leadRadius","radius","Math","rotate","backgroundColor","values","radiusName","borderRadius"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js"],"sourcesContent":["import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { getValueTransition } from '../../../animation/utils/transitions.js';\nimport { motionValue } from '../../../value/index.js';\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = __assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, __assign(__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync.read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}