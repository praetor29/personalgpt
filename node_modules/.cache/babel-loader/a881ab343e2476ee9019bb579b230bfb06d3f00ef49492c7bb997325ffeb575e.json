{"ast":null,"code":"import { zeroLayout } from '../../utils/state.js';\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n    y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n      rotateX = latestTransform.rotateX,\n      rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };","map":{"version":3,"names":["zeroLayout","buildLayoutProjectionTransform","_a","treeScale","latestTransform","x","y","xTranslate","translate","yTranslate","transform","rotate","rotateX","rotateY","scale","identityProjection","buildLayoutProjectionTransformOrigin","deltaFinal","origin","delta"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js"],"sourcesContent":["import { zeroLayout } from '../../utils/state.js';\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,sBAAsB;;AAEjD;AACA;AACA;AACA;AACA,SAASC,8BAA8BA,CAACC,EAAE,EAAEC,SAAS,EAAEC,eAAe,EAAE;EACpE,IAAIC,CAAC,GAAGH,EAAE,CAACG,CAAC;IAAEC,CAAC,GAAGJ,EAAE,CAACI,CAAC;EACtB;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAGF,CAAC,CAACG,SAAS,GAAGL,SAAS,CAACE,CAAC;EAC1C,IAAII,UAAU,GAAGH,CAAC,CAACE,SAAS,GAAGL,SAAS,CAACG,CAAC;EAC1C,IAAII,SAAS,GAAG,cAAc,GAAGH,UAAU,GAAG,MAAM,GAAGE,UAAU,GAAG,SAAS;EAC7E,IAAIL,eAAe,EAAE;IACjB,IAAIO,MAAM,GAAGP,eAAe,CAACO,MAAM;MAAEC,OAAO,GAAGR,eAAe,CAACQ,OAAO;MAAEC,OAAO,GAAGT,eAAe,CAACS,OAAO;IACzG,IAAIF,MAAM,EACND,SAAS,IAAI,SAAS,GAAGC,MAAM,GAAG,IAAI;IAC1C,IAAIC,OAAO,EACPF,SAAS,IAAI,UAAU,GAAGE,OAAO,GAAG,IAAI;IAC5C,IAAIC,OAAO,EACPH,SAAS,IAAI,UAAU,GAAGG,OAAO,GAAG,IAAI;EAChD;EACAH,SAAS,IAAI,QAAQ,GAAGL,CAAC,CAACS,KAAK,GAAG,IAAI,GAAGR,CAAC,CAACQ,KAAK,GAAG,GAAG;EACtD,OAAO,CAACV,eAAe,IAAIM,SAAS,KAAKK,kBAAkB,GAAG,EAAE,GAAGL,SAAS;AAChF;AACA;AACA;AACA;AACA,SAASM,oCAAoCA,CAACd,EAAE,EAAE;EAC9C,IAAIe,UAAU,GAAGf,EAAE,CAACe,UAAU;EAC9B,OAAOA,UAAU,CAACZ,CAAC,CAACa,MAAM,GAAG,GAAG,GAAG,IAAI,GAAGD,UAAU,CAACX,CAAC,CAACY,MAAM,GAAG,GAAG,GAAG,KAAK;AAC/E;AACA,IAAIH,kBAAkB,GAAGd,8BAA8B,CAACD,UAAU,CAACmB,KAAK,EAAEnB,UAAU,CAACG,SAAS,EAAE;EAAEE,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC,CAAC;AAE/G,SAASL,8BAA8B,EAAEe,oCAAoC,EAAED,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}