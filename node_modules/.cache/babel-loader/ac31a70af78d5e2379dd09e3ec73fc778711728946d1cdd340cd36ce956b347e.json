{"ast":null,"code":"/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n// Support for asynchronous functions\n\n\"use strict\";\n\nvar aFrom = require(\"es5-ext/array/from\"),\n  objectMap = require(\"es5-ext/object/map\"),\n  mixin = require(\"es5-ext/object/mixin\"),\n  defineLength = require(\"es5-ext/function/_define-length\"),\n  nextTick = require(\"next-tick\");\nvar slice = Array.prototype.slice,\n  apply = Function.prototype.apply,\n  create = Object.create;\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n  var waiting = create(null),\n    cache = create(null),\n    base = conf.memoized,\n    original = conf.original,\n    currentCallback,\n    currentContext,\n    currentArgs;\n\n  // Initial\n  conf.memoized = defineLength(function (arg) {\n    var args = arguments,\n      last = args[args.length - 1];\n    if (typeof last === \"function\") {\n      currentCallback = last;\n      args = slice.call(args, 0, -1);\n    }\n    return base.apply(currentContext = this, currentArgs = args);\n  }, base);\n  try {\n    mixin(conf.memoized, base);\n  } catch (ignore) {}\n\n  // From cache (sync)\n  conf.on(\"get\", function (id) {\n    var cb, context, args;\n    if (!currentCallback) return;\n\n    // Unresolved\n    if (waiting[id]) {\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];else waiting[id].push(currentCallback);\n      currentCallback = null;\n      return;\n    }\n\n    // Resolved, assure next tick invocation\n    cb = currentCallback;\n    context = currentContext;\n    args = currentArgs;\n    currentCallback = currentContext = currentArgs = null;\n    nextTick(function () {\n      var data;\n      if (hasOwnProperty.call(cache, id)) {\n        data = cache[id];\n        conf.emit(\"getasync\", id, args, context);\n        apply.call(cb, data.context, data.args);\n      } else {\n        // Purged in a meantime, we shouldn't rely on cached value, recall\n        currentCallback = cb;\n        currentContext = context;\n        currentArgs = args;\n        base.apply(context, args);\n      }\n    });\n  });\n\n  // Not from cache\n  conf.original = function () {\n    var args, cb, origCb, result;\n    if (!currentCallback) return apply.call(original, this, arguments);\n    args = aFrom(arguments);\n    cb = function self(err) {\n      var cb,\n        args,\n        id = self.id;\n      if (id == null) {\n        // Shouldn't happen, means async callback was called sync way\n        nextTick(apply.bind(self, this, arguments));\n        return undefined;\n      }\n      delete self.id;\n      cb = waiting[id];\n      delete waiting[id];\n      if (!cb) {\n        // Already processed,\n        // outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n        return undefined;\n      }\n      args = aFrom(arguments);\n      if (conf.has(id)) {\n        if (err) {\n          conf.delete(id);\n        } else {\n          cache[id] = {\n            context: this,\n            args: args\n          };\n          conf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n        }\n      }\n      if (typeof cb === \"function\") {\n        result = apply.call(cb, this, args);\n      } else {\n        cb.forEach(function (cb) {\n          result = apply.call(cb, this, args);\n        }, this);\n      }\n      return result;\n    };\n    origCb = currentCallback;\n    currentCallback = currentContext = currentArgs = null;\n    args.push(cb);\n    result = apply.call(original, this, args);\n    cb.cb = origCb;\n    currentCallback = cb;\n    return result;\n  };\n\n  // After not from cache call\n  conf.on(\"set\", function (id) {\n    if (!currentCallback) {\n      conf.delete(id);\n      return;\n    }\n    if (waiting[id]) {\n      // Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];else waiting[id].push(currentCallback.cb);\n    } else {\n      waiting[id] = currentCallback.cb;\n    }\n    delete currentCallback.cb;\n    currentCallback.id = id;\n    currentCallback = null;\n  });\n\n  // On delete\n  conf.on(\"delete\", function (id) {\n    var result;\n    // If false, we don't have value yet, so we assume that intention is not\n    // to memoize this call. After value is obtained we don't cache it but\n    // gracefully pass to callback\n    if (hasOwnProperty.call(waiting, id)) return;\n    if (!cache[id]) return;\n    result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n  });\n\n  // On clear\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return slice.call(data.args, 1);\n    }));\n  });\n};","map":{"version":3,"names":["aFrom","require","objectMap","mixin","defineLength","nextTick","slice","Array","prototype","apply","Function","create","Object","async","tbi","conf","waiting","cache","base","memoized","original","currentCallback","currentContext","currentArgs","arg","args","arguments","last","length","call","ignore","on","id","cb","context","push","data","hasOwnProperty","emit","origCb","result","self","err","bind","undefined","has","delete","forEach","oldCache"],"sources":["C:/Users/prana/AppData/Local/Yarn/Berry/cache/memoizee-npm-0.4.15-69d374fc14-10c0.zip/node_modules/memoizee/ext/async.js"],"sourcesContent":["/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n// Support for asynchronous functions\n\n\"use strict\";\n\nvar aFrom        = require(\"es5-ext/array/from\")\n  , objectMap    = require(\"es5-ext/object/map\")\n  , mixin        = require(\"es5-ext/object/mixin\")\n  , defineLength = require(\"es5-ext/function/_define-length\")\n  , nextTick     = require(\"next-tick\");\n\nvar slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n\tvar waiting = create(null)\n\t  , cache = create(null)\n\t  , base = conf.memoized\n\t  , original = conf.original\n\t  , currentCallback\n\t  , currentContext\n\t  , currentArgs;\n\n\t// Initial\n\tconf.memoized = defineLength(function (arg) {\n\t\tvar args = arguments, last = args[args.length - 1];\n\t\tif (typeof last === \"function\") {\n\t\t\tcurrentCallback = last;\n\t\t\targs = slice.call(args, 0, -1);\n\t\t}\n\t\treturn base.apply(currentContext = this, currentArgs = args);\n\t}, base);\n\ttry { mixin(conf.memoized, base); }\n\tcatch (ignore) {}\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id) {\n\t\tvar cb, context, args;\n\t\tif (!currentCallback) return;\n\n\t\t// Unresolved\n\t\tif (waiting[id]) {\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];\n\t\t\telse waiting[id].push(currentCallback);\n\t\t\tcurrentCallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Resolved, assure next tick invocation\n\t\tcb = currentCallback;\n\t\tcontext = currentContext;\n\t\targs = currentArgs;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\tnextTick(function () {\n\t\t\tvar data;\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tdata = cache[id];\n\t\t\t\tconf.emit(\"getasync\", id, args, context);\n\t\t\t\tapply.call(cb, data.context, data.args);\n\t\t\t} else {\n\t\t\t\t// Purged in a meantime, we shouldn't rely on cached value, recall\n\t\t\t\tcurrentCallback = cb;\n\t\t\t\tcurrentContext = context;\n\t\t\t\tcurrentArgs = args;\n\t\t\t\tbase.apply(context, args);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Not from cache\n\tconf.original = function () {\n\t\tvar args, cb, origCb, result;\n\t\tif (!currentCallback) return apply.call(original, this, arguments);\n\t\targs = aFrom(arguments);\n\t\tcb = function self(err) {\n\t\t\tvar cb, args, id = self.id;\n\t\t\tif (id == null) {\n\t\t\t\t// Shouldn't happen, means async callback was called sync way\n\t\t\t\tnextTick(apply.bind(self, this, arguments));\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tdelete self.id;\n\t\t\tcb = waiting[id];\n\t\t\tdelete waiting[id];\n\t\t\tif (!cb) {\n\t\t\t\t// Already processed,\n\t\t\t\t// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\targs = aFrom(arguments);\n\t\t\tif (conf.has(id)) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconf.delete(id);\n\t\t\t\t} else {\n\t\t\t\t\tcache[id] = { context: this, args: args };\n\t\t\t\t\tconf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\tresult = apply.call(cb, this, args);\n\t\t\t} else {\n\t\t\t\tcb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\torigCb = currentCallback;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\targs.push(cb);\n\t\tresult = apply.call(original, this, args);\n\t\tcb.cb = origCb;\n\t\tcurrentCallback = cb;\n\t\treturn result;\n\t};\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id) {\n\t\tif (!currentCallback) {\n\t\t\tconf.delete(id);\n\t\t\treturn;\n\t\t}\n\t\tif (waiting[id]) {\n\t\t\t// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];\n\t\t\telse waiting[id].push(currentCallback.cb);\n\t\t} else {\n\t\t\twaiting[id] = currentCallback.cb;\n\t\t}\n\t\tdelete currentCallback.cb;\n\t\tcurrentCallback.id = id;\n\t\tcurrentCallback = null;\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tvar result;\n\t\t// If false, we don't have value yet, so we assume that intention is not\n\t\t// to memoize this call. After value is obtained we don't cache it but\n\t\t// gracefully pass to callback\n\t\tif (hasOwnProperty.call(waiting, id)) return;\n\t\tif (!cache[id]) return;\n\t\tresult = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\tconf.emit(\n\t\t\t\"clearasync\", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })\n\t\t);\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}