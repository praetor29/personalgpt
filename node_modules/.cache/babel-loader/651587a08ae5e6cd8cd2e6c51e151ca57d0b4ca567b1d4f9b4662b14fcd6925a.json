{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StatefulEvt = void 0;\n// @denoify-line-ignore\nrequire(\"minimal-polyfills/Object.is\");\nvar LazyEvt_1 = require(\"./LazyEvt\");\nvar LazyStatefulEvt_1 = require(\"./LazyStatefulEvt\");\nvar importProxy_1 = require(\"./importProxy\");\nvar Evt_2 = require(\"./Evt\");\nvar assert_1 = require(\"tsafe/assert\");\nvar id_1 = require(\"tsafe/id\");\nvar runSideEffect = function (sideEffect) {\n  return sideEffect();\n};\nvar StatefulEvtImpl = /** @class */function (_super) {\n  __extends(StatefulEvtImpl, _super);\n  function StatefulEvtImpl(initialState) {\n    var _this_1 = _super.call(this) || this;\n    _this_1.lazyEvtDiff = new LazyEvt_1.LazyEvt();\n    _this_1.lazyEvtChangeDiff = new LazyEvt_1.LazyEvt();\n    _this_1.__state = initialState;\n    _this_1.lazyEvtChange = new LazyStatefulEvt_1.LazyStatefulEvt(_this_1.__state);\n    Evt_2.onAddHandlerByEvt.set(_this_1, function (handler, handlerTrigger) {\n      if (handler.extract) {\n        return;\n      }\n      var sideEffect = (0, id_1.id)(undefined);\n      var opResult = _this_1.getInvocableOp(handler.op)(_this_1.__state, _this_1.setOpResultForPipe !== undefined ? function (sideEffect_) {\n        return sideEffect = sideEffect_;\n      } : runSideEffect);\n      if (_this_1.setOpResultForPipe !== undefined) {\n        _this_1.setOpResultForPipe(opResult);\n        if (sideEffect !== undefined) {\n          sideEffect();\n        }\n      }\n      if (!opResult) {\n        return;\n      }\n      handlerTrigger(opResult);\n    });\n    return _this_1;\n  }\n  Object.defineProperty(StatefulEvtImpl.prototype, \"state\", {\n    get: function () {\n      return this.__state;\n    },\n    set: function (value) {\n      if (this.state === value) return;\n      this.post(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StatefulEvtImpl.prototype, \"evtDiff\", {\n    get: function () {\n      return this.lazyEvtDiff.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StatefulEvtImpl.prototype, \"evtChange\", {\n    get: function () {\n      return this.lazyEvtChange.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StatefulEvtImpl.prototype, \"evtChangeDiff\", {\n    get: function () {\n      return this.lazyEvtChangeDiff.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  StatefulEvtImpl.prototype.post = function (data) {\n    return this.__post(data, false, false);\n  };\n  StatefulEvtImpl.prototype.postForceChange = function (wData) {\n    return this.__post(!!wData ? wData[0] : this.state, true, false);\n  };\n  StatefulEvtImpl.prototype.postAndWait = function (data) {\n    return this.__post(data, false, true);\n  };\n  StatefulEvtImpl.prototype.__post = function (data, forceChange, doWait) {\n    var prevState = this.state;\n    this.__state = data;\n    var diff = {\n      prevState: prevState,\n      \"newState\": this.state\n    };\n    var postVariantName = doWait ? \"postAndWait\" : \"post\";\n    var prs = [];\n    var r1 = this.lazyEvtDiff[postVariantName](diff);\n    if (doWait) {\n      prs.push(r1);\n    }\n    if (forceChange || !Object.is(prevState, this.state)) {\n      var r2 = this.lazyEvtChange[postVariantName](this.state);\n      var r3 = this.lazyEvtChangeDiff[postVariantName](diff);\n      if (doWait) {\n        prs.push(r2, r3);\n      }\n    }\n    var r4 = _super.prototype[postVariantName].call(this, data);\n    return doWait ? (prs.push(r4), Promise.all(prs).then(function () {})) : r4;\n  };\n  StatefulEvtImpl.prototype.pipe = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var opResult = undefined;\n    this.setOpResultForPipe = function (opResult_) {\n      return opResult = opResult_;\n    };\n    var evt = _super.prototype.pipe.apply(this, __spreadArray([], __read(args), false));\n    (0, assert_1.assert)(opResult !== undefined);\n    this.setOpResultForPipe = undefined;\n    if (!opResult) {\n      throw new Error([\"Cannot pipe StatefulEvt because the operator does not match\", \"it's current state. You would end up with evt.state === undefined\", \"Use evt.toStateless([ctx]).pipe(op).toStatic(initialState)\", \"to be sure the StatefulEvt does not have an undefined state\"].join(\" \"));\n    }\n    return evt.toStateful(opResult[0]);\n  };\n  StatefulEvtImpl.prototype.toStateless = function (ctx) {\n    var onAddHandler = Evt_2.onAddHandlerByEvt.get(this);\n    Evt_2.onAddHandlerByEvt.delete(this);\n    var out = !!ctx ? _super.prototype.pipe.call(this, ctx) : _super.prototype.pipe.call(this);\n    Evt_2.onAddHandlerByEvt.set(this, onAddHandler);\n    return out;\n  };\n  return StatefulEvtImpl;\n}(Evt_2.Evt);\nexports.StatefulEvt = StatefulEvtImpl;\nimportProxy_1.importProxy.StatefulEvt = exports.StatefulEvt;","map":{"version":3,"names":["require","LazyEvt_1","LazyStatefulEvt_1","importProxy_1","Evt_2","assert_1","id_1","runSideEffect","sideEffect","StatefulEvtImpl","_super","__extends","initialState","_this_1","call","lazyEvtDiff","LazyEvt","lazyEvtChangeDiff","__state","lazyEvtChange","LazyStatefulEvt","onAddHandlerByEvt","set","handler","handlerTrigger","extract","id","undefined","opResult","getInvocableOp","op","setOpResultForPipe","sideEffect_","Object","defineProperty","prototype","get","value","state","post","evt","data","__post","postForceChange","wData","postAndWait","forceChange","doWait","prevState","diff","postVariantName","prs","r1","push","is","r2","r3","r4","Promise","all","then","pipe","args","_i","arguments","length","opResult_","apply","__spreadArray","__read","assert","Error","join","toStateful","toStateless","ctx","onAddHandler","delete","out","Evt","exports","StatefulEvt","importProxy"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\evt-npm-2.5.3-c2ac0365d2-10c0.zip\\node_modules\\evt\\src\\lib\\StatefulEvt.ts"],"sourcesContent":["// @denoify-line-ignore\nimport \"minimal-polyfills/Object.is\";\nimport { LazyEvt } from \"./LazyEvt\";\nimport { LazyStatefulEvt } from \"./LazyStatefulEvt\";\nimport { importProxy } from \"./importProxy\";\nimport { Evt, onAddHandlerByEvt } from \"./Evt\";\nimport type { CtxLike, StateDiff, NonPostableEvt, StatefulReadonlyEvt } from \"./types\";\nimport { assert } from \"tsafe/assert\";\nimport { id } from \"tsafe/id\";\n\n/** https://docs.evt.land/api/statefulevt */\nexport type StatefulEvt<T> = import(\"./types/interfaces\").StatefulEvt<T>;\n\nconst runSideEffect = (sideEffect: ()=> void) => sideEffect();\n\nclass StatefulEvtImpl<T> extends Evt<T> implements StatefulEvt<T> {\n\n    __state: T;\n    get state(): T { return this.__state; }\n    set state(value: T) {\n        if (this.state === value) return; \n        this.post(value);\n    }\n\n    constructor(initialState: T) {\n        super();\n        this.__state = initialState;\n        this.lazyEvtChange = new LazyStatefulEvt(this.__state);\n\n        onAddHandlerByEvt.set(\n            this,\n            (handler, handlerTrigger) => {\n\n                if( handler.extract ){\n                    return;\n                }\n\n                let sideEffect= id<(()=> void) | undefined>(undefined);\n\n\n                const opResult = this.getInvocableOp(handler.op)(\n                    this.__state,\n                    this.setOpResultForPipe !== undefined ? (sideEffect_=>sideEffect =sideEffect_) : runSideEffect\n                );\n\n                if( this.setOpResultForPipe !== undefined ){\n                    this.setOpResultForPipe(opResult);\n                    if( sideEffect !== undefined ){\n                        sideEffect();\n                    }\n                }\n\n                if (!opResult) {\n                    return;\n                }\n\n                handlerTrigger(opResult);\n\n            }\n        );\n    }\n\n    private readonly lazyEvtDiff = new LazyEvt<StateDiff<T>>();\n    get evtDiff(): NonPostableEvt<StateDiff<T>> { return this.lazyEvtDiff.evt; }\n\n    private readonly lazyEvtChange: LazyStatefulEvt<T>;\n    get evtChange(): StatefulReadonlyEvt<T> { return this.lazyEvtChange.evt; }\n\n    private readonly lazyEvtChangeDiff = new LazyEvt<StateDiff<T>>();\n    get evtChangeDiff(): NonPostableEvt<StateDiff<T>> { return this.lazyEvtChangeDiff.evt; }\n\n    post(data: T): number {\n        return this.__post(data, false, false);\n    }\n\n    postForceChange(wData?: readonly [T]): number {\n        return this.__post(!!wData ? wData[0] : this.state, true, false);\n    }\n\n    postAndWait(data: T) {\n        return this.__post(data, false, true);\n    }\n\n    private __post(data: T, forceChange: boolean, doWait: false): number;\n    private __post(data: T, forceChange: boolean, doWait: true): Promise<void>;\n    private __post(data: T, forceChange: boolean, doWait: boolean): number | Promise<void> {\n\n        const prevState = this.state;\n\n        this.__state = data;\n\n        const diff = { prevState, \"newState\": this.state };\n\n        const postVariantName = doWait ? \"postAndWait\" : \"post\";\n\n        const prs: Promise<void>[] = [];\n\n        const r1 = this.lazyEvtDiff[postVariantName](diff);\n\n        if (doWait) {\n            prs.push(r1 as any);\n        }\n\n        if (forceChange || !Object.is(prevState, this.state)) {\n            const r2 = this.lazyEvtChange[postVariantName](this.state);\n            const r3 = this.lazyEvtChangeDiff[postVariantName](diff);\n\n            if (doWait) {\n                prs.push(r2 as any, r3 as any);\n            }\n\n        }\n\n        const r4 = super[postVariantName](data);\n\n        return doWait ?\n            (prs.push(r4 as any), Promise.all(prs).then(() => { })) :\n            r4;\n\n    }\n\n    private setOpResultForPipe: ((opResult: readonly [any] | null) => void) | undefined;\n\n    pipe(...args: any[]): StatefulEvt<any> {\n\n        let opResult: readonly [any] | null | undefined = undefined;\n\n        this.setOpResultForPipe = opResult_ => opResult = opResult_;\n\n        const evt = super\n            .pipe(...(args as Parameters<typeof importProxy.Evt.prototype.pipe>))\n            ;\n\n        assert(opResult !== undefined);\n\n        this.setOpResultForPipe = undefined;\n\n        if (!opResult) {\n\n            throw new Error([\n                \"Cannot pipe StatefulEvt because the operator does not match\",\n                \"it's current state. You would end up with evt.state === undefined\",\n                \"Use evt.toStateless([ctx]).pipe(op).toStatic(initialState)\",\n                \"to be sure the StatefulEvt does not have an undefined state\"\n            ].join(\" \"));\n\n        }\n\n        return evt.toStateful(opResult[0]);\n\n    }\n\n    toStateless(ctx?: CtxLike): Evt<any> {\n\n        const onAddHandler=  onAddHandlerByEvt.get(this)!;\n\n        onAddHandlerByEvt.delete(this);\n\n        const out= !!ctx ? super.pipe(ctx) : super.pipe();\n\n        onAddHandlerByEvt.set(this, onAddHandler);\n\n        return out;\n    }\n\n}\n\nexport const StatefulEvt: {\n    new <T>(initialState: T): StatefulEvt<T>;\n    readonly prototype: StatefulEvt<any>;\n} = StatefulEvtImpl;\n\nimportProxy.StatefulEvt = StatefulEvt;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}