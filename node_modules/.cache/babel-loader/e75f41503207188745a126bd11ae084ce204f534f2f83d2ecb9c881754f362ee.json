{"ast":null,"code":"// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d = require(\"d\"),\n  validateSymbol = require(\"./validate-symbol\"),\n  NativeSymbol = require(\"ext/global-this\").Symbol,\n  generateName = require(\"./lib/private/generate-name\"),\n  setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\"),\n  setupSymbolRegistry = require(\"./lib/private/setup/symbol-registry\");\nvar create = Object.create,\n  defineProperties = Object.defineProperties,\n  defineProperty = Object.defineProperty;\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\nif (typeof NativeSymbol === \"function\") {\n  try {\n    String(NativeSymbol());\n    isNativeSafe = true;\n  } catch (ignore) {}\n} else {\n  NativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n  if (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n  return SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n  var symbol;\n  if (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n  if (isNativeSafe) return NativeSymbol(description);\n  symbol = create(HiddenSymbol.prototype);\n  description = description === undefined ? \"\" : String(description);\n  return defineProperties(symbol, {\n    __description__: d(\"\", description),\n    __name__: d(\"\", generateName(description))\n  });\n};\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n  constructor: d(SymbolPolyfill),\n  toString: d(\"\", function () {\n    return this.__name__;\n  })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n  toString: d(function () {\n    return \"Symbol (\" + validateSymbol(this).__description__ + \")\";\n  }),\n  valueOf: d(function () {\n    return validateSymbol(this);\n  })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d(\"\", function () {\n  var symbol = validateSymbol(this);\n  if (typeof symbol === \"symbol\") return symbol;\n  return symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));","map":{"version":3,"names":["d","require","validateSymbol","NativeSymbol","Symbol","generateName","setupStandardSymbols","setupSymbolRegistry","create","Object","defineProperties","defineProperty","SymbolPolyfill","HiddenSymbol","isNativeSafe","String","ignore","description","TypeError","module","exports","symbol","prototype","undefined","__description__","__name__","constructor","toString","valueOf","toPrimitive","toStringTag"],"sources":["C:/Users/prana/AppData/Local/Yarn/Berry/cache/es6-symbol-npm-3.1.3-34d72f2a23-10c0.zip/node_modules/es6-symbol/polyfill.js"],"sourcesContent":["// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d                    = require(\"d\")\n  , validateSymbol       = require(\"./validate-symbol\")\n  , NativeSymbol         = require(\"ext/global-this\").Symbol\n  , generateName         = require(\"./lib/private/generate-name\")\n  , setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\")\n  , setupSymbolRegistry  = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create\n  , defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty;\n\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n} else {\n\tNativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = description === undefined ? \"\" : String(description);\n\treturn defineProperties(symbol, {\n\t\t__description__: d(\"\", description),\n\t\t__name__: d(\"\", generateName(description))\n\t});\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d(\"\", function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return \"Symbol (\" + validateSymbol(this).__description__ + \")\"; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(\n\tSymbolPolyfill.prototype,\n\tSymbolPolyfill.toPrimitive,\n\td(\"\", function () {\n\t\tvar symbol = validateSymbol(this);\n\t\tif (typeof symbol === \"symbol\") return symbol;\n\t\treturn symbol.toString();\n\t})\n);\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])\n);\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}