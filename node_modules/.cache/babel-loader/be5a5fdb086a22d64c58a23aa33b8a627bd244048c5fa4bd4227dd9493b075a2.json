{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertOperatorToStatelessFλ = void 0;\nfunction encapsulateOpState(statefulFλOp) {\n  var state = statefulFλOp[1];\n  return function (data, registerSideEffect) {\n    var opResult = statefulFλOp[0](data, state, registerSideEffect);\n    if (opResult !== null) {\n      registerSideEffect(function () {\n        return state = opResult[0];\n      });\n    }\n    return opResult;\n  };\n}\nfunction statelessOpToStatelessFλ(op) {\n  return function (data, registerSideEffect) {\n    /* NOTE: Here, if the user is using TypeScript we should have readonly [U] or boolean\n     * but users using vanilla JS can very well provide operators like: text => text.match(/^error/)\n     * and expect things to work event if String.prototype.match returns a RegExpMatch array instead\n     * of boolean.\n     * Long story short we do our best to guess what the user meant with he's operator, if it was\n     * intended to be a filter or a fλ.\n     */\n    var opResult = op(data, registerSideEffect);\n    return opResult instanceof Object && !(\"input\" in opResult) &&\n    //exclude String.prototype.match\n    opResult.length === 1 ? opResult : !!opResult ? [data] : null;\n  };\n}\n;\nfunction convertOperatorToStatelessFλ(op) {\n  return typeof op !== \"function\" ? encapsulateOpState(op) : statelessOpToStatelessFλ(op);\n}\nexports.convertOperatorToStatelessFλ = convertOperatorToStatelessFλ;","map":{"version":3,"names":["encapsulateOpState","statefulFλOp","state","data","registerSideEffect","opResult","statelessOpToStatelessFλ","op","Object","length","convertOperatorToStatelessFλ","exports"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\evt-npm-2.5.3-c2ac0365d2-10c0.zip\\node_modules\\evt\\src\\lib\\util\\convertOperatorToStatelessFLambda.ts"],"sourcesContent":["\nimport type { Operator } from \"../types/Operator\";\n\nfunction encapsulateOpState<T, U>(\n    statefulFλOp: Operator.fλ.Stateful<T, U>\n): Operator.fλ.Stateless<T, U> {\n\n    let state: U = statefulFλOp[1];\n\n    return (data, registerSideEffect) => {\n\n        const opResult = statefulFλOp[0](data, state, registerSideEffect);\n\n        if (opResult !== null) {\n            registerSideEffect(() => state = opResult[0])\n        }\n\n        return opResult;\n\n    };\n\n}\n\nfunction statelessOpToStatelessFλ<T, U>(op: Operator.Stateless<T, U>): Operator.fλ.Stateless<T, U> {\n    return (data, registerSideEffect) => {\n\n        /* NOTE: Here, if the user is using TypeScript we should have readonly [U] or boolean\n         * but users using vanilla JS can very well provide operators like: text => text.match(/^error/) \n         * and expect things to work event if String.prototype.match returns a RegExpMatch array instead \n         * of boolean. \n         * Long story short we do our best to guess what the user meant with he's operator, if it was\n         * intended to be a filter or a fλ.\n         */\n        const opResult: any = (op as Operator.fλ.Stateless<T, U>)(data, registerSideEffect);\n\n        return (\n            opResult instanceof Object &&\n            !(\"input\" in opResult) && //exclude String.prototype.match\n            opResult.length === 1\n        ) ?\n            opResult\n            :\n            !!opResult ? [data] : null;\n\n    }\n};\n\nexport function convertOperatorToStatelessFλ<T, U>(\n    op: Operator<T, U>\n): Operator.fλ.Stateless<T, U> {\n    return typeof op !== \"function\" ?\n        encapsulateOpState(op) :\n        statelessOpToStatelessFλ(op);\n}\n"],"mappings":";;;;;;AAGA,SAASA,kBAAkBA,CACvBC,YAAwC;EAGxC,IAAIC,KAAK,GAAMD,YAAY,CAAC,CAAC,CAAC;EAE9B,OAAO,UAACE,IAAI,EAAEC,kBAAkB;IAE5B,IAAMC,QAAQ,GAAGJ,YAAY,CAAC,CAAC,CAAC,CAACE,IAAI,EAAED,KAAK,EAAEE,kBAAkB,CAAC;IAEjE,IAAIC,QAAQ,KAAK,IAAI,EAAE;MACnBD,kBAAkB,CAAC;QAAM,OAAAF,KAAK,GAAGG,QAAQ,CAAC,CAAC,CAAC;MAAnB,CAAmB,CAAC;;IAGjD,OAAOA,QAAQ;EAEnB,CAAC;AAEL;AAEA,SAASC,wBAAwBA,CAAOC,EAA4B;EAChE,OAAO,UAACJ,IAAI,EAAEC,kBAAkB;IAE5B;;;;;;;IAOA,IAAMC,QAAQ,GAASE,EAAkC,CAACJ,IAAI,EAAEC,kBAAkB,CAAC;IAEnF,OACIC,QAAQ,YAAYG,MAAM,IAC1B,EAAE,OAAO,IAAIH,QAAQ,CAAC;IAAI;IAC1BA,QAAQ,CAACI,MAAM,KAAK,CAAC,GAErBJ,QAAQ,GAER,CAAC,CAACA,QAAQ,GAAG,CAACF,IAAI,CAAC,GAAG,IAAI;EAElC,CAAC;AACL;AAAC;AAED,SAAgBO,4BAA4BA,CACxCH,EAAkB;EAElB,OAAO,OAAOA,EAAE,KAAK,UAAU,GAC3BP,kBAAkB,CAACO,EAAE,CAAC,GACtBD,wBAAwB,CAACC,EAAE,CAAC;AACpC;AANAI,OAAA,CAAAD,4BAAA,GAAAA,4BAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}