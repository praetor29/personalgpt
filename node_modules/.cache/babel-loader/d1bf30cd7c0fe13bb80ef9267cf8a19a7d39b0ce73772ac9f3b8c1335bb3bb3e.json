{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createI18nApiFactory = void 0;\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst LocalizedString_1 = require(\"./LocalizedString\");\nconst useGuaranteedMemo_1 = require(\"powerhooks/useGuaranteedMemo\");\nconst symToStr_1 = require(\"tsafe/symToStr\");\nconst assert_1 = require(\"tsafe/assert\");\nconst objectKeys_1 = require(\"tsafe/objectKeys\");\nconst StatefulObservable_1 = require(\"powerhooks/tools/StatefulObservable\");\nconst exclude_1 = require(\"tsafe/exclude\");\nfunction createI18nApiFactory(params) {\n  const {\n    createUseLang\n  } = params;\n  /** @see <https://docs.i18nifty.dev> */\n  function createI18nApi() {\n    return function (params, translations) {\n      const {\n        languages,\n        fallbackLanguage\n      } = params;\n      const {\n        useLang,\n        $lang,\n        withLang\n      } = (() => {\n        const result = createUseLang({\n          languages,\n          fallbackLanguage\n        });\n        const {\n          useLang,\n          $lang\n        } = result;\n        const {\n          withLang\n        } = result;\n        return {\n          useLang,\n          $lang,\n          withLang\n        };\n      })();\n      const fetchingTranslations = {};\n      const fetchedTranslations = Object.fromEntries(Object.entries(translations).filter(([, value]) => typeof value !== \"function\"));\n      const $isFetchingOrNeverFetched = (0, StatefulObservable_1.createStatefulObservable)(() => true);\n      function useIsI18nFetching() {\n        (0, StatefulObservable_1.useRerenderOnChange)($isFetchingOrNeverFetched);\n        return $isFetchingOrNeverFetched.current;\n      }\n      const $translationFetched = (0, StatefulObservable_1.createStatefulObservable)(() => 0);\n      lazy_fetch: {\n        if (withLang !== undefined) {\n          //TODO: Support lazy fetching for SSR\n          break lazy_fetch;\n        }\n        const next = lang => {\n          if (fetchedTranslations[lang] !== undefined || fetchingTranslations[lang] !== undefined) {\n            return;\n          }\n          const fetchTranslations = translations[lang];\n          (0, assert_1.assert)(typeof fetchTranslations === \"function\");\n          $isFetchingOrNeverFetched.current = true;\n          const pr = fetchTranslations();\n          fetchingTranslations[lang] = pr;\n          pr.then(translation => {\n            fetchingTranslations[lang] = undefined;\n            fetchedTranslations[lang] = translation;\n            $translationFetched.current++;\n            const notifyIfNoLongerFetchingIfItsTheCase = () => {\n              if ((0, objectKeys_1.objectKeys)(fetchingTranslations).map(lang => fetchingTranslations[lang]).filter((0, exclude_1.exclude)(undefined)).length !== 0) {\n                return;\n              }\n              $isFetchingOrNeverFetched.current = false;\n            };\n            if (lang === fallbackLanguage || fetchedTranslations[fallbackLanguage] !== undefined) {\n              notifyIfNoLongerFetchingIfItsTheCase();\n              return;\n            }\n            if ((0, objectKeys_1.objectKeys)(translation).map(componentName => translation[componentName]).map(componentTranslation => (0, objectKeys_1.objectKeys)(componentTranslation).map(key => componentTranslation[key]).includes(undefined)).flat().includes(true)) {\n              next(fallbackLanguage);\n            } else {\n              notifyIfNoLongerFetchingIfItsTheCase();\n            }\n          });\n        };\n        next($lang.current);\n        $lang.subscribe(next);\n      }\n      function useResolveLocalizedString(params) {\n        const {\n          labelWhenMismatchingLanguage\n        } = params !== null && params !== void 0 ? params : {};\n        const {\n          lang\n        } = useLang();\n        const {\n          resolveLocalizedString,\n          resolveLocalizedStringDetailed\n        } = (0, useGuaranteedMemo_1.useGuaranteedMemo)(() => {\n          const {\n            resolveLocalizedString,\n            resolveLocalizedStringDetailed\n          } = (0, LocalizedString_1.createResolveLocalizedString)({\n            \"currentLanguage\": lang,\n            fallbackLanguage,\n            \"labelWhenMismatchingLanguage\": labelWhenMismatchingLanguage\n          });\n          return {\n            resolveLocalizedString,\n            resolveLocalizedStringDetailed\n          };\n        }, [lang, typeof labelWhenMismatchingLanguage === \"object\" ? labelWhenMismatchingLanguage.ifStringAssumeLanguage : labelWhenMismatchingLanguage]);\n        return {\n          resolveLocalizedString,\n          resolveLocalizedStringDetailed\n        };\n      }\n      function getTranslationForLanguage(params) {\n        const {\n          componentName,\n          getLang\n        } = params;\n        const t = (key, params) => {\n          const lang = getLang();\n          if (fetchedTranslations[lang] === undefined) {\n            return \"\";\n          }\n          const getStrOrFn = lang => {\n            //return (fetchedTranslations as any)[lang][componentName][key];\n            const translation = fetchedTranslations[lang];\n            if (translation === undefined) {\n              return \"\";\n            }\n            return translation[componentName][key];\n          };\n          let strOrFn = getStrOrFn(lang);\n          if (strOrFn === undefined) {\n            strOrFn = getStrOrFn(fallbackLanguage);\n          }\n          return params === undefined ? strOrFn : strOrFn(params);\n        };\n        return {\n          t\n        };\n      }\n      function useTranslation(componentNameAsKey) {\n        const {\n          lang\n        } = useLang();\n        (0, StatefulObservable_1.useRerenderOnChange)($translationFetched);\n        const componentName = (0, symToStr_1.symToStr)(componentNameAsKey);\n        const {\n          t\n        } = (0, useGuaranteedMemo_1.useGuaranteedMemo)(() => getTranslationForLanguage({\n          \"getLang\": () => lang,\n          componentName\n        }), [lang, componentName, $translationFetched.current]);\n        return {\n          t\n        };\n      }\n      function getTranslation(componentName) {\n        const {\n          t\n        } = getTranslationForLanguage({\n          componentName,\n          \"getLang\": () => $lang.current\n        });\n        return {\n          t\n        };\n      }\n      function resolveLocalizedString(localizedString, options) {\n        const {\n          labelWhenMismatchingLanguage\n        } = options !== null && options !== void 0 ? options : {};\n        const {\n          resolveLocalizedString\n        } = (0, LocalizedString_1.createResolveLocalizedString)({\n          \"currentLanguage\": $lang.current,\n          fallbackLanguage,\n          \"labelWhenMismatchingLanguage\": labelWhenMismatchingLanguage\n        });\n        return resolveLocalizedString(localizedString);\n      }\n      const i18nApi = {\n        useLang,\n        useTranslation,\n        useResolveLocalizedString,\n        resolveLocalizedString,\n        $lang,\n        useIsI18nFetching,\n        getTranslation\n      };\n      return Object.assign(Object.assign({}, i18nApi), {\n        withLang\n      });\n    };\n  }\n  return {\n    createI18nApi\n  };\n}\nexports.createI18nApiFactory = createI18nApiFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","createI18nApiFactory","LocalizedString_1","require","useGuaranteedMemo_1","symToStr_1","assert_1","objectKeys_1","StatefulObservable_1","exclude_1","params","createUseLang","createI18nApi","translations","languages","fallbackLanguage","useLang","$lang","withLang","result","fetchingTranslations","fetchedTranslations","fromEntries","entries","filter","$isFetchingOrNeverFetched","createStatefulObservable","useIsI18nFetching","useRerenderOnChange","current","$translationFetched","lazy_fetch","undefined","next","lang","fetchTranslations","assert","pr","then","translation","notifyIfNoLongerFetchingIfItsTheCase","objectKeys","map","exclude","length","componentName","componentTranslation","key","includes","flat","subscribe","useResolveLocalizedString","labelWhenMismatchingLanguage","resolveLocalizedString","resolveLocalizedStringDetailed","useGuaranteedMemo","createResolveLocalizedString","ifStringAssumeLanguage","getTranslationForLanguage","getLang","t","getStrOrFn","strOrFn","useTranslation","componentNameAsKey","symToStr","getTranslation","localizedString","options","i18nApi","assign"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/i18nifty-virtual-f94293219d/3/AppData/Local/Yarn/Berry/cache/i18nifty-npm-1.6.2-79bdda185a-10c0.zip/node_modules/i18nifty/createI18nApi.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createI18nApiFactory = void 0;\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst LocalizedString_1 = require(\"./LocalizedString\");\nconst useGuaranteedMemo_1 = require(\"powerhooks/useGuaranteedMemo\");\nconst symToStr_1 = require(\"tsafe/symToStr\");\nconst assert_1 = require(\"tsafe/assert\");\nconst objectKeys_1 = require(\"tsafe/objectKeys\");\nconst StatefulObservable_1 = require(\"powerhooks/tools/StatefulObservable\");\nconst exclude_1 = require(\"tsafe/exclude\");\nfunction createI18nApiFactory(params) {\n    const { createUseLang } = params;\n    /** @see <https://docs.i18nifty.dev> */\n    function createI18nApi() {\n        return function (params, translations) {\n            const { languages, fallbackLanguage } = params;\n            const { useLang, $lang, withLang } = (() => {\n                const result = createUseLang({\n                    languages,\n                    fallbackLanguage\n                });\n                const { useLang, $lang } = result;\n                const { withLang } = result;\n                return { useLang, $lang, withLang };\n            })();\n            const fetchingTranslations = {};\n            const fetchedTranslations = Object.fromEntries(Object.entries(translations).filter(([, value]) => typeof value !== \"function\"));\n            const $isFetchingOrNeverFetched = (0, StatefulObservable_1.createStatefulObservable)(() => true);\n            function useIsI18nFetching() {\n                (0, StatefulObservable_1.useRerenderOnChange)($isFetchingOrNeverFetched);\n                return $isFetchingOrNeverFetched.current;\n            }\n            const $translationFetched = (0, StatefulObservable_1.createStatefulObservable)(() => 0);\n            lazy_fetch: {\n                if (withLang !== undefined) {\n                    //TODO: Support lazy fetching for SSR\n                    break lazy_fetch;\n                }\n                const next = (lang) => {\n                    if (fetchedTranslations[lang] !== undefined ||\n                        fetchingTranslations[lang] !== undefined) {\n                        return;\n                    }\n                    const fetchTranslations = translations[lang];\n                    (0, assert_1.assert)(typeof fetchTranslations === \"function\");\n                    $isFetchingOrNeverFetched.current = true;\n                    const pr = fetchTranslations();\n                    fetchingTranslations[lang] = pr;\n                    pr.then(translation => {\n                        fetchingTranslations[lang] = undefined;\n                        fetchedTranslations[lang] = translation;\n                        $translationFetched.current++;\n                        const notifyIfNoLongerFetchingIfItsTheCase = () => {\n                            if ((0, objectKeys_1.objectKeys)(fetchingTranslations)\n                                .map(lang => fetchingTranslations[lang])\n                                .filter((0, exclude_1.exclude)(undefined)).length !== 0) {\n                                return;\n                            }\n                            $isFetchingOrNeverFetched.current = false;\n                        };\n                        if (lang === fallbackLanguage ||\n                            fetchedTranslations[fallbackLanguage] !== undefined) {\n                            notifyIfNoLongerFetchingIfItsTheCase();\n                            return;\n                        }\n                        if ((0, objectKeys_1.objectKeys)(translation)\n                            .map(componentName => translation[componentName])\n                            .map(componentTranslation => (0, objectKeys_1.objectKeys)(componentTranslation)\n                            .map(key => componentTranslation[key])\n                            .includes(undefined))\n                            .flat()\n                            .includes(true)) {\n                            next(fallbackLanguage);\n                        }\n                        else {\n                            notifyIfNoLongerFetchingIfItsTheCase();\n                        }\n                    });\n                };\n                next($lang.current);\n                $lang.subscribe(next);\n            }\n            function useResolveLocalizedString(params) {\n                const { labelWhenMismatchingLanguage } = params !== null && params !== void 0 ? params : {};\n                const { lang } = useLang();\n                const { resolveLocalizedString, resolveLocalizedStringDetailed } = (0, useGuaranteedMemo_1.useGuaranteedMemo)(() => {\n                    const { resolveLocalizedString, resolveLocalizedStringDetailed } = (0, LocalizedString_1.createResolveLocalizedString)({\n                        \"currentLanguage\": lang,\n                        fallbackLanguage,\n                        \"labelWhenMismatchingLanguage\": labelWhenMismatchingLanguage\n                    });\n                    return {\n                        resolveLocalizedString,\n                        resolveLocalizedStringDetailed\n                    };\n                }, [\n                    lang,\n                    typeof labelWhenMismatchingLanguage === \"object\"\n                        ? labelWhenMismatchingLanguage.ifStringAssumeLanguage\n                        : labelWhenMismatchingLanguage\n                ]);\n                return {\n                    resolveLocalizedString,\n                    resolveLocalizedStringDetailed\n                };\n            }\n            function getTranslationForLanguage(params) {\n                const { componentName, getLang } = params;\n                const t = (key, params) => {\n                    const lang = getLang();\n                    if (fetchedTranslations[lang] === undefined) {\n                        return \"\";\n                    }\n                    const getStrOrFn = (lang) => {\n                        //return (fetchedTranslations as any)[lang][componentName][key];\n                        const translation = fetchedTranslations[lang];\n                        if (translation === undefined) {\n                            return \"\";\n                        }\n                        return translation[componentName][key];\n                    };\n                    let strOrFn = getStrOrFn(lang);\n                    if (strOrFn === undefined) {\n                        strOrFn = getStrOrFn(fallbackLanguage);\n                    }\n                    return params === undefined ? strOrFn : strOrFn(params);\n                };\n                return { t };\n            }\n            function useTranslation(componentNameAsKey) {\n                const { lang } = useLang();\n                (0, StatefulObservable_1.useRerenderOnChange)($translationFetched);\n                const componentName = (0, symToStr_1.symToStr)(componentNameAsKey);\n                const { t } = (0, useGuaranteedMemo_1.useGuaranteedMemo)(() => getTranslationForLanguage({\n                    \"getLang\": () => lang,\n                    componentName\n                }), [lang, componentName, $translationFetched.current]);\n                return { t };\n            }\n            function getTranslation(componentName) {\n                const { t } = getTranslationForLanguage({\n                    componentName,\n                    \"getLang\": () => $lang.current\n                });\n                return { t };\n            }\n            function resolveLocalizedString(localizedString, options) {\n                const { labelWhenMismatchingLanguage } = options !== null && options !== void 0 ? options : {};\n                const { resolveLocalizedString } = (0, LocalizedString_1.createResolveLocalizedString)({\n                    \"currentLanguage\": $lang.current,\n                    fallbackLanguage,\n                    \"labelWhenMismatchingLanguage\": labelWhenMismatchingLanguage\n                });\n                return resolveLocalizedString(localizedString);\n            }\n            const i18nApi = {\n                useLang,\n                useTranslation,\n                useResolveLocalizedString,\n                resolveLocalizedString,\n                $lang,\n                useIsI18nFetching,\n                getTranslation\n            };\n            return Object.assign(Object.assign({}, i18nApi), { withLang });\n        };\n    }\n    return { createI18nApi };\n}\nexports.createI18nApiFactory = createI18nApiFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}