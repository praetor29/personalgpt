{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Ctx = void 0;\n// @denoify-line-ignore\nvar Set_1 = require(\"minimal-polyfills/Set\");\n// @denoify-line-ignore\nvar WeakMap_1 = require(\"minimal-polyfills/WeakMap\");\nvar assert_1 = require(\"tsafe/assert\");\n;\nvar is_1 = require(\"tsafe/is\");\nvar LazyEvt_1 = require(\"./LazyEvt\");\nvar importProxy_1 = require(\"./importProxy\");\nvar overwriteReadonlyProp_1 = require(\"tsafe/lab/overwriteReadonlyProp\");\nvar CtxImpl = /** @class */function () {\n  function CtxImpl() {\n    this.lazyEvtAttach = new LazyEvt_1.LazyEvt();\n    this.lazyEvtDetach = new LazyEvt_1.LazyEvt();\n    this.lazyEvtDoneOrAborted = new LazyEvt_1.LazyEvt();\n    this.handlers = new Set_1.Polyfill();\n    this.evtByHandler = new WeakMap_1.Polyfill();\n  }\n  Object.defineProperty(CtxImpl.prototype, \"evtDoneOrAborted\", {\n    get: function () {\n      return this.lazyEvtDoneOrAborted.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CtxImpl.prototype, \"evtAttach\", {\n    get: function () {\n      return this.lazyEvtAttach.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CtxImpl.prototype, \"evtDetach\", {\n    get: function () {\n      return this.lazyEvtDetach.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CtxImpl.prototype, \"completionStatus\", {\n    get: function () {\n      return this.__completionStatus;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  CtxImpl.prototype.onDoneOrAborted = function (doneOrAborted) {\n    this.__completionStatus = doneOrAborted;\n    this.lazyEvtDoneOrAborted.post(doneOrAborted);\n  };\n  CtxImpl.prototype.waitFor = function (timeout) {\n    var _this_1 = this;\n    return this.evtDoneOrAborted.waitFor(timeout).then(function (data) {\n      if (data.type === \"ABORTED\") {\n        throw data.error;\n      }\n      return data.result;\n    }, function (timeoutError) {\n      _this_1.abort(timeoutError);\n      throw timeoutError;\n    });\n  };\n  CtxImpl.prototype.abort = function (error) {\n    return this.__done(error);\n  };\n  CtxImpl.prototype.done = function (result) {\n    return this.__done(undefined, result);\n  };\n  /** Detach all handler bound to this context from theirs respective Evt and post getEvtDone() */\n  CtxImpl.prototype.__done = function (error, result) {\n    var e_1, _a;\n    var handlers = [];\n    try {\n      for (var _b = __values(this.handlers.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var handler = _c.value;\n        var evt = this.evtByHandler.get(handler);\n        var wasStillAttached = handler.detach();\n        //NOTE: It should not be possible\n        if (!wasStillAttached) {\n          continue;\n        }\n        handlers.push({\n          handler: handler,\n          evt: evt\n        });\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    this.onDoneOrAborted(__assign(__assign({}, !!error ? {\n      type: \"ABORTED\",\n      error: error\n    } : {\n      type: \"DONE\",\n      \"result\": result\n    }), {\n      handlers: handlers\n    }));\n    return handlers;\n  };\n  CtxImpl.prototype.getHandlers = function () {\n    var _this_1 = this;\n    return Array.from(this.handlers.values()).map(function (handler) {\n      return {\n        handler: handler,\n        \"evt\": _this_1.evtByHandler.get(handler)\n      };\n    });\n  };\n  CtxImpl.prototype.zz__addHandler = function (handler, evt) {\n    (0, assert_1.assert)(handler.ctx === this);\n    (0, assert_1.assert)((0, is_1.is)(handler));\n    if (this.completionStatus !== undefined) {\n      handler.detach();\n      return;\n    }\n    this.handlers.add(handler);\n    this.evtByHandler.set(handler, evt);\n    this.lazyEvtAttach.post({\n      handler: handler,\n      evt: evt\n    });\n  };\n  CtxImpl.prototype.zz__removeHandler = function (handler) {\n    (0, assert_1.assert)(handler.ctx === this);\n    (0, assert_1.assert)((0, is_1.is)(handler));\n    this.lazyEvtDetach.post({\n      handler: handler,\n      \"evt\": this.evtByHandler.get(handler)\n    });\n    this.handlers.delete(handler);\n  };\n  return CtxImpl;\n}();\nexports.Ctx = CtxImpl;\ntry {\n  (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(exports.Ctx, \"name\", \"Ctx\");\n} catch (_a) {}\nimportProxy_1.importProxy.Ctx = exports.Ctx;","map":{"version":3,"names":["Set_1","require","WeakMap_1","assert_1","is_1","LazyEvt_1","importProxy_1","overwriteReadonlyProp_1","CtxImpl","lazyEvtAttach","LazyEvt","lazyEvtDetach","lazyEvtDoneOrAborted","handlers","Polyfill","evtByHandler","Object","defineProperty","prototype","get","evt","__completionStatus","onDoneOrAborted","doneOrAborted","post","waitFor","timeout","_this_1","evtDoneOrAborted","then","data","type","error","result","timeoutError","abort","__done","done","undefined","_b","__values","values","_c","next","handler","value","wasStillAttached","detach","push","__assign","getHandlers","Array","from","map","zz__addHandler","assert","ctx","is","completionStatus","add","set","zz__removeHandler","delete","exports","Ctx","overwriteReadonlyProp","_a","importProxy"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\evt-npm-2.5.3-c2ac0365d2-10c0.zip\\node_modules\\evt\\src\\lib\\Ctx.ts"],"sourcesContent":["// @denoify-line-ignore\nimport { Polyfill as Set } from \"minimal-polyfills/Set\";\n// @denoify-line-ignore\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport { assert } from \"tsafe/assert\";;\nimport { is } from \"tsafe/is\";\nimport { LazyEvt } from \"./LazyEvt\";\nimport { importProxy } from \"./importProxy\";\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\n\nimport type { \n    Handler, \n    NonPostableEvtLike,\n    Evt,\n    CtxLike,\n    DoneOrAborted\n} from \"./types\";\n\nexport type Ctx<Result = void> = import(\"./types/interfaces\").Ctx<Result>;\n\nclass CtxImpl<Result> implements Ctx<Result>{\n\n\n    get evtDoneOrAborted(): Evt<DoneOrAborted<Result>> {\n        return this.lazyEvtDoneOrAborted.evt;\n    }\n\n    get evtAttach(): Evt<Handler.WithEvt<any, Result>> {\n        return this.lazyEvtAttach.evt;\n    }\n\n    get evtDetach(): Evt<Handler.WithEvt<any, Result>> {\n        return this.lazyEvtDetach.evt;\n    }\n\n    private __completionStatus: DoneOrAborted<Result> | undefined;\n\n    get completionStatus(): DoneOrAborted<Result> | undefined {\n        return this.__completionStatus;\n    }\n\n\n    private lazyEvtAttach = new LazyEvt<Handler.WithEvt<any, Result>>();\n    private lazyEvtDetach = new LazyEvt<Handler.WithEvt<any, Result>>();\n    private lazyEvtDoneOrAborted = new LazyEvt<DoneOrAborted<Result>>();\n\n    private onDoneOrAborted(doneOrAborted: DoneOrAborted<Result>): void {\n\n        this.__completionStatus = doneOrAborted;\n\n        this.lazyEvtDoneOrAborted.post(doneOrAborted);\n    }\n\n    waitFor(timeout?: number): Promise<Result> {\n        return this.evtDoneOrAborted\n            .waitFor(timeout)\n            .then(\n                data => {\n                    if (data.type === \"ABORTED\") {\n                        throw data.error;\n                    }\n                    return data.result;\n                },\n                timeoutError => {\n                    this.abort(timeoutError);\n                    throw timeoutError;\n                }\n            )\n            ;\n    }\n\n\n    abort(error: Error) {\n        return this.__done(error);\n    }\n\n    done(result: Result) {\n        return this.__done(undefined, result);\n    }\n\n    /** Detach all handler bound to this context from theirs respective Evt and post getEvtDone() */\n    private __done(error: Error | undefined, result?: Result): Handler.WithEvt<any, Result>[] {\n\n        const handlers: Handler.WithEvt<any, Result>[] = [];\n\n        for (const handler of this.handlers.values()) {\n\n            const evt = this.evtByHandler.get(handler)!;\n\n            const wasStillAttached = handler.detach();\n\n            //NOTE: It should not be possible\n            if (!wasStillAttached) {\n                continue;\n            }\n\n            handlers.push({ handler, evt });\n        }\n\n        this.onDoneOrAborted({\n            ...(!!error ?\n                { type: \"ABORTED\", error } :\n                { type: \"DONE\", \"result\": result as NonNullable<typeof result> }\n            ),\n            handlers\n        });\n\n\n        return handlers;\n\n    }\n\n    private handlers = new Set<\n        Handler<any, any, Ctx<Result>>\n    >();\n    private evtByHandler = new WeakMap<\n        Handler<any, any, Ctx<Result>>,\n        NonPostableEvtLike<any>\n    >();\n\n    getHandlers(): Handler.WithEvt<any, Result>[] {\n        return Array.from(this.handlers.values())\n            .map(handler => ({ handler, \"evt\": this.evtByHandler.get(handler)! }))\n            ;\n    }\n\n\n    zz__addHandler<T>(\n        handler: Handler<T, any, CtxLike<Result>>,\n        evt: NonPostableEvtLike<T>\n    ) {\n        assert(handler.ctx === this);\n        assert(is<Handler<T, any, Ctx<Result>>>(handler));\n\n        if( this.completionStatus !== undefined ){\n            handler.detach();\n            return;\n        }\n\n        this.handlers.add(handler);\n        this.evtByHandler.set(handler, evt);\n        this.lazyEvtAttach.post({ handler, evt });\n    }\n\n    zz__removeHandler<T>(\n        handler: Handler<T, any, CtxLike<Result>>,\n    ) {\n        assert(handler.ctx === this);\n        assert(is<Handler<T, any, Ctx<Result>>>(handler));\n\n        this.lazyEvtDetach.post({\n            handler,\n            \"evt\": this.evtByHandler.get(handler)!\n        });\n\n        this.handlers.delete(handler);\n    }\n\n}\n\nexport const Ctx: {\n    new <Result>(): Ctx<Result>;\n    readonly prototype: Ctx<any>;\n} = CtxImpl;\n\ntry{ overwriteReadonlyProp(Ctx as any, \"name\", \"Ctx\"); }catch{}\n\nimportProxy.Ctx = Ctx;\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}