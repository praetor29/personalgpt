{"ast":null,"code":"import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */function (_super) {\n  __extends(AnimateSharedLayout, _super);\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n    var handler = {\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return;\n    // Create stack if it doesn't already exist\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n  AnimateSharedLayout.prototype.render = function () {\n    return React.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React.Component);\nexport { AnimateSharedLayout };","map":{"version":3,"names":["__extends","__assign","React","Presence","layoutStack","SharedLayoutContext","MotionContext","resetRotate","createBatcher","snapshotViewportBox","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","shouldResetTransform","resetTransform","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","createElement","Provider","value","contextType","Component"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"sourcesContent":["import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC3C,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,mBAAmB,QAAQ,sCAAsC;AAC1E,SAASC,aAAa,QAAQ,sCAAsC;AACpE,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,mBAAmB,QAAQ,sCAAsC;;AAE1E;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACvDX,SAAS,CAACU,mBAAmB,EAAEC,MAAM,CAAC;EACtC,SAASD,mBAAmBA,CAAA,EAAG;IAC3B,IAAIE,KAAK,GAAGD,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,IAAI,IAAI;IACpE;AACR;AACA;IACQF,KAAK,CAACG,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC1B;AACR;AACA;AACA;AACA;IACQJ,KAAK,CAACK,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxB;AACR;AACA;AACA;IACQN,KAAK,CAACO,UAAU,GAAG,KAAK;IACxB;AACR;AACA;AACA;IACQP,KAAK,CAACQ,eAAe,GAAG,KAAK;IAC7B;AACR;AACA;IACQR,KAAK,CAACS,eAAe,GAAG,KAAK;IAC7B;AACR;AACA;IACQT,KAAK,CAACU,WAAW,GAAGrB,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEO,aAAa,CAAC,CAAC,CAAC,EAAE;MAAEe,UAAU,EAAE,SAAAA,CAAUC,KAAK,EAAE;QAAE,OAAOZ,KAAK,CAACa,cAAc,CAACD,KAAK,CAAC;MAAE,CAAC;MAAEE,WAAW,EAAE,SAAAA,CAAA,EAAY;QACrJ;QACA;QACAd,KAAK,CAACU,WAAW,GAAGrB,QAAQ,CAAC,CAAC,CAAC,EAAEW,KAAK,CAACU,WAAW,CAAC;QACnDV,KAAK,CAACa,cAAc,CAAC,IAAI,CAAC;MAC9B,CAAC;MAAEE,QAAQ,EAAE,SAAAA,CAAUC,KAAK,EAAE;QAAE,OAAOhB,KAAK,CAACiB,QAAQ,CAACD,KAAK,CAAC;MAAE,CAAC;MAAEE,MAAM,EAAE,SAAAA,CAAUF,KAAK,EAAE;QAAE,OAAOhB,KAAK,CAACmB,WAAW,CAACH,KAAK,CAAC;MAAE;IAAE,CAAC,CAAC;IACrI,OAAOhB,KAAK;EAChB;EACAF,mBAAmB,CAACsB,SAAS,CAACC,iBAAiB,GAAG,YAAY;IAC1D,IAAI,CAACd,UAAU,GAAG,IAAI;EAC1B,CAAC;EACDT,mBAAmB,CAACsB,SAAS,CAACE,kBAAkB,GAAG,YAAY;IAC3D,IAAI,CAACC,oBAAoB,CAAC,CAAC;EAC/B,CAAC;EACDzB,mBAAmB,CAACsB,SAAS,CAACI,qBAAqB,GAAG,YAAY;IAC9D,IAAI,CAACf,eAAe,GAAG,IAAI;IAC3B,OAAO,IAAI;EACf,CAAC;EACDX,mBAAmB,CAACsB,SAAS,CAACG,oBAAoB,GAAG,YAAY;IAC7D,IAAIvB,KAAK,GAAG,IAAI;IAChB;AACR;AACA;IACQ,IAAI,CAACS,eAAe,GAAG,IAAI,CAACD,eAAe,GAAG,KAAK;IACnD,IAAIiB,IAAI,GAAG,IAAI,CAACC,KAAK,CAACD,IAAI;IAC1B;AACR;AACA;AACA;IACQ,IAAI,CAACtB,QAAQ,CAACwB,OAAO,CAAC,UAAUX,KAAK,EAAE;MACnC,IAAI,CAACA,KAAK,CAACY,SAAS,EAAE;QAClBZ,KAAK,CAACa,QAAQ,GAAGtC,QAAQ,CAACuC,OAAO;MACrC,CAAC,MACI,IAAId,KAAK,CAACa,QAAQ,KAAKtC,QAAQ,CAACwC,QAAQ,EAAE;QAC3Cf,KAAK,CAACa,QAAQ,GACVb,KAAK,CAACa,QAAQ,KAAKtC,QAAQ,CAACuC,OAAO,GAC7BvC,QAAQ,CAACwC,QAAQ,GACjBxC,QAAQ,CAACyC,OAAO;MAC9B;IACJ,CAAC,CAAC;IACF,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB;AACR;AACA;IACQ,IAAIC,OAAO,GAAG;MACVC,WAAW,EAAE,SAAAA,CAAUnB,KAAK,EAAE;QAC1B,IAAIA,KAAK,CAACoB,WAAW,CAAC,CAAC,KAAKC,SAAS,EAAE;UACnC,IAAIC,KAAK,GAAGtC,KAAK,CAACuC,QAAQ,CAACvB,KAAK,CAAC;UACjCsB,KAAK,CAACE,OAAO,CAACxB,KAAK,EAAES,IAAI,KAAK,WAAW,CAAC;QAC9C,CAAC,MACI;UACDT,KAAK,CAACyB,iBAAiB,CAAC,CAAC;QAC7B;MACJ,CAAC;MACDC,MAAM,EAAE,IAAI,CAACC,OAAO,CAACC;IACzB,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACzC,QAAQ,CAACwB,OAAO,CAAC,UAAUX,KAAK,EAAE;MAAE,OAAOhB,KAAK,CAACU,WAAW,CAACmC,GAAG,CAAC7B,KAAK,CAAC;IAAE,CAAC,CAAC;IAChF,IAAI,CAACN,WAAW,CAACoC,KAAK,CAACZ,OAAO,CAAC;IAC/B;AACR;AACA;IACQ,IAAI,CAAC7B,MAAM,CAACsB,OAAO,CAAC,UAAUW,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACS,aAAa,CAAC,CAAC;IAAE,CAAC,CAAC;EAC3E,CAAC;EACDjD,mBAAmB,CAACsB,SAAS,CAACa,YAAY,GAAG,YAAY;IACrD,IAAI,CAAC5B,MAAM,CAACsB,OAAO,CAAC,UAAUW,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACU,mBAAmB,CAAC,CAAC;IAAE,CAAC,CAAC;EACjF,CAAC;EACDlD,mBAAmB,CAACsB,SAAS,CAACP,cAAc,GAAG,UAAUD,KAAK,EAAE;IAC5D,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,KAAK;IAAE;IACvC,IAAI,EAAEA,KAAK,IAAI,CAAC,IAAI,CAACJ,eAAe,CAAC,EACjC;IACJ;AACR;AACA;IACQ,IAAI,CAACA,eAAe,GAAG,IAAI;IAC3B;AACR;AACA;IACQ,IAAI,CAACL,QAAQ,CAACwB,OAAO,CAAC,UAAUX,KAAK,EAAE;MACnCrB,WAAW,CAACqB,KAAK,CAAC;MAClB,IAAIA,KAAK,CAACiC,oBAAoB,CAAC,CAAC,EAC5BjC,KAAK,CAACkC,cAAc,CAAC,CAAC;IAC9B,CAAC,CAAC;IACF;AACR;AACA;IACQ,IAAI,CAAC/C,QAAQ,CAACwB,OAAO,CAAC9B,mBAAmB,CAAC;IAC1C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACQ,MAAM,CAACsB,OAAO,CAAC,UAAUW,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACa,cAAc,CAAC,CAAC;IAAE,CAAC,CAAC;IACxE;AACR;AACA;IACQ,IAAIvC,KAAK,IAAI,CAAC,IAAI,CAACH,eAAe,EAAE;MAChC,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACK,WAAW,CAAC,CAAC;IACtB;EACJ,CAAC;EACDhB,mBAAmB,CAACsB,SAAS,CAACH,QAAQ,GAAG,UAAUD,KAAK,EAAE;IACtD,IAAI,CAACb,QAAQ,CAAC0C,GAAG,CAAC7B,KAAK,CAAC;IACxB,IAAI,CAACoC,UAAU,CAACpC,KAAK,CAAC;IACtBA,KAAK,CAACa,QAAQ,GAAG,IAAI,CAACtB,UAAU,GAAGhB,QAAQ,CAACwC,QAAQ,GAAGxC,QAAQ,CAACyC,OAAO;EAC3E,CAAC;EACDlC,mBAAmB,CAACsB,SAAS,CAACD,WAAW,GAAG,UAAUH,KAAK,EAAE;IACzD,IAAI,CAACH,cAAc,CAAC,CAAC;IACrB,IAAI,CAACV,QAAQ,CAACkD,MAAM,CAACrC,KAAK,CAAC;IAC3B,IAAI,CAACsC,eAAe,CAACtC,KAAK,CAAC;EAC/B,CAAC;EACDlB,mBAAmB,CAACsB,SAAS,CAACgC,UAAU,GAAG,UAAUpC,KAAK,EAAE;IACxD,IAAIsB,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACvB,KAAK,CAAC;IAChCsB,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACO,GAAG,CAAC7B,KAAK,CAAC;EAClE,CAAC;EACDlB,mBAAmB,CAACsB,SAAS,CAACkC,eAAe,GAAG,UAAUtC,KAAK,EAAE;IAC7D,IAAIsB,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACvB,KAAK,CAAC;IAChCsB,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACpB,MAAM,CAACF,KAAK,CAAC;EACrE,CAAC;EACD;AACJ;AACA;AACA;EACIlB,mBAAmB,CAACsB,SAAS,CAACmB,QAAQ,GAAG,UAAUvB,KAAK,EAAE;IACtD,IAAIuC,EAAE,GAAGvC,KAAK,CAACoB,WAAW,CAAC,CAAC;IAC5B,IAAImB,EAAE,KAAKlB,SAAS,EAChB;IACJ;IACA,CAAC,IAAI,CAAChC,MAAM,CAACmD,GAAG,CAACD,EAAE,CAAC,IAAI,IAAI,CAAClD,MAAM,CAACoD,GAAG,CAACF,EAAE,EAAE/D,WAAW,CAAC,CAAC,CAAC;IAC1D,OAAO,IAAI,CAACa,MAAM,CAACqD,GAAG,CAACH,EAAE,CAAC;EAC9B,CAAC;EACDzD,mBAAmB,CAACsB,SAAS,CAACuC,MAAM,GAAG,YAAY;IAC/C,OAAQrE,KAAK,CAACsE,aAAa,CAACnE,mBAAmB,CAACoE,QAAQ,EAAE;MAAEC,KAAK,EAAE,IAAI,CAACpD;IAAY,CAAC,EAAE,IAAI,CAACgB,KAAK,CAACvB,QAAQ,CAAC;EAC/G,CAAC;EACDL,mBAAmB,CAACiE,WAAW,GAAGrE,aAAa;EAC/C,OAAOI,mBAAmB;AAC9B,CAAC,CAACR,KAAK,CAAC0E,SAAS,CAAE;AAEnB,SAASlE,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}