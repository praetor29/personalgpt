{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.id = void 0;\n/** https://docs.tsafe.dev/id  */\nvar id = function (x) {\n  return x;\n};\nexports.id = id;","map":{"version":3,"names":["id","x","exports"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\tsafe-npm-1.6.5-e2f1226ddb-10c0.zip\\node_modules\\tsafe\\src\\id.ts"],"sourcesContent":["/** https://docs.tsafe.dev/id  */\nexport const id = <T>(x: T) => x;\n\n/**\n * Ensure that a that a specific type that we are declaring extends a more generic type\n *\n * Use case example 1:\n *\n * type MyObject = {\n *     p1: string;\n *     p2: string;\n *     a: string;\n *     b: string;\n * };\n *\n * We want to define a type that consist in an union of\n * all the property name that are letters:\n *\n * type AlphabeticalKeys = Id<keyof MyObject, \"a\" | \"b\">;\n *\n * Here AlphabeticalKeys is \"a\" | \"b\" but it's better than\n * simply writing it explicitly as we get autocompletion\n * and we can't include a property name that does not exist on MyObject.\n *\n * Use case example 2:\n *\n * We want to declare object type that only take string or number\n * as key value:\n *\n * export type MyObject = Id<Record<string, string | number>, {\n *     p1: string;\n *     p2: number;\n * }>;\n *\n * If later on someone adds \"p3\": string[] he will get a type error.\n * */\nexport type Id<Generic, Specific extends Generic> = Specific;\n"],"mappings":";;;;;;AAAA;AACO,IAAMA,EAAE,GAAG,SAAAA,CAAIC,CAAI;EAAK,OAAAA,CAAC;AAAD,CAAC;AAAnBC,OAAA,CAAAF,EAAE,GAAAA,EAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}