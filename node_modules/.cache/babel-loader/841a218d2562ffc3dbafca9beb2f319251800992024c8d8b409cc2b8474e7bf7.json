{"ast":null,"code":"import { __assign } from 'tslib';\nimport { complex, px } from 'style-value-types';\nimport { mix } from 'popmotion';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\n   * If latest is a string, if it's a percentage we can return immediately as it's\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n   */\n  if (typeof latest === \"string\") {\n    if (px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n    treeScale = _a.treeScale;\n  var original = latest;\n  /**\n   * We need to first strip and store CSS variables from the string.\n   */\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n  var shadow = complex.parse(latest);\n  // TODO: Doesn't support multiple shadows\n  if (shadow.length > 5) return original;\n  var template = complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n  // Calculate the overall context scale\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n  var averageScale = mix(xScale, yScale, 0.5);\n  // Blur\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n  // Spread\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n  return output;\n}\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };","map":{"version":3,"names":["__assign","complex","px","mix","cssVariableRegex","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","latest","_layoutState","_a","target","test","parseFloat","x","y","varToken","correctBoxShadow","delta","treeScale","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","scale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","process","defaultScaleCorrectors","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/render/dom/projection/default-scale-correctors.js"],"sourcesContent":["import { __assign } from 'tslib';\nimport { complex, px } from 'style-value-types';\nimport { mix } from 'popmotion';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nexport { correctBorderRadius, correctBoxShadow, defaultScaleCorrectors, pixelsToPercent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}