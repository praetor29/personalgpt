{"ast":null,"code":"/* eslint max-statements: 0 */\n\n// Support for functions returning promise\n\n\"use strict\";\n\nvar objectMap = require(\"es5-ext/object/map\"),\n  primitiveSet = require(\"es5-ext/object/primitive-set\"),\n  ensureString = require(\"es5-ext/object/validate-stringifiable-value\"),\n  toShortString = require(\"es5-ext/to-short-string-representation\"),\n  isPromise = require(\"is-promise\"),\n  nextTick = require(\"next-tick\");\nvar create = Object.create,\n  supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n  var waiting = create(null),\n    cache = create(null),\n    promises = create(null);\n  if (mode === true) {\n    mode = null;\n  } else {\n    mode = ensureString(mode);\n    if (!supportedModes[mode]) {\n      throw new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n    }\n  }\n\n  // After not from cache call\n  conf.on(\"set\", function (id, ignore, promise) {\n    var isFailed = false;\n    if (!isPromise(promise)) {\n      // Non promise result\n      cache[id] = promise;\n      conf.emit(\"setasync\", id, 1);\n      return;\n    }\n    waiting[id] = 1;\n    promises[id] = promise;\n    var onSuccess = function (result) {\n      var count = waiting[id];\n      if (isFailed) {\n        throw new Error(\"Memoizee error: Detected unordered then|done & finally resolution, which \" + \"in turn makes proper detection of success/failure impossible (when in \" + \"'done:finally' mode)\\n\" + \"Consider to rely on 'then' or 'done' mode instead.\");\n      }\n      if (!count) return; // Deleted from cache before resolved\n      delete waiting[id];\n      cache[id] = result;\n      conf.emit(\"setasync\", id, count);\n    };\n    var onFailure = function () {\n      isFailed = true;\n      if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n      delete waiting[id];\n      delete promises[id];\n      conf.delete(id);\n    };\n    var resolvedMode = mode;\n    if (!resolvedMode) resolvedMode = \"then\";\n    if (resolvedMode === \"then\") {\n      var nextTickFailure = function () {\n        nextTick(onFailure);\n      };\n      // Eventual finally needs to be attached to non rejected promise\n      // (so we not force propagation of unhandled rejection)\n      promise = promise.then(function (result) {\n        nextTick(onSuccess.bind(this, result));\n      }, nextTickFailure);\n      // If `finally` is a function we attach to it to remove cancelled promises.\n      if (typeof promise.finally === \"function\") {\n        promise.finally(nextTickFailure);\n      }\n    } else if (resolvedMode === \"done\") {\n      // Not recommended, as it may mute any eventual \"Unhandled error\" events\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done' mode\");\n      }\n      promise.done(onSuccess, onFailure);\n    } else if (resolvedMode === \"done:finally\") {\n      // The only mode with no side effects assuming library does not throw unconditionally\n      // for rejected promises.\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done:finally' mode\");\n      }\n      if (typeof promise.finally !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'finally' \" + \"in 'done:finally' mode\");\n      }\n      promise.done(onSuccess);\n      promise.finally(onFailure);\n    }\n  });\n\n  // From cache (sync)\n  conf.on(\"get\", function (id, args, context) {\n    var promise;\n    if (waiting[id]) {\n      ++waiting[id]; // Still waiting\n      return;\n    }\n    promise = promises[id];\n    var emit = function () {\n      conf.emit(\"getasync\", id, args, context);\n    };\n    if (isPromise(promise)) {\n      if (typeof promise.done === \"function\") promise.done(emit);else {\n        promise.then(function () {\n          nextTick(emit);\n        });\n      }\n    } else {\n      emit();\n    }\n  });\n\n  // On delete\n  conf.on(\"delete\", function (id) {\n    delete promises[id];\n    if (waiting[id]) {\n      delete waiting[id];\n      return; // Not yet resolved\n    }\n\n    if (!hasOwnProperty.call(cache, id)) return;\n    var result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, [result]);\n  });\n\n  // On clear\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    waiting = create(null);\n    promises = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return [data];\n    }));\n  });\n};","map":{"version":3,"names":["objectMap","require","primitiveSet","ensureString","toShortString","isPromise","nextTick","create","Object","supportedModes","promise","mode","conf","waiting","cache","promises","TypeError","on","id","ignore","isFailed","emit","onSuccess","result","count","Error","onFailure","delete","resolvedMode","nextTickFailure","then","bind","finally","done","args","context","hasOwnProperty","call","oldCache","data"],"sources":["C:/Users/prana/AppData/Local/Yarn/Berry/cache/memoizee-npm-0.4.15-69d374fc14-10c0.zip/node_modules/memoizee/ext/promise.js"],"sourcesContent":["/* eslint max-statements: 0 */\n\n// Support for functions returning promise\n\n\"use strict\";\n\nvar objectMap     = require(\"es5-ext/object/map\")\n  , primitiveSet  = require(\"es5-ext/object/primitive-set\")\n  , ensureString  = require(\"es5-ext/object/validate-stringifiable-value\")\n  , toShortString = require(\"es5-ext/to-short-string-representation\")\n  , isPromise     = require(\"is-promise\")\n  , nextTick      = require(\"next-tick\");\n\nvar create = Object.create\n  , supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n\tvar waiting = create(null), cache = create(null), promises = create(null);\n\n\tif (mode === true) {\n\t\tmode = null;\n\t} else {\n\t\tmode = ensureString(mode);\n\t\tif (!supportedModes[mode]) {\n\t\t\tthrow new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n\t\t}\n\t}\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id, ignore, promise) {\n\t\tvar isFailed = false;\n\n\t\tif (!isPromise(promise)) {\n\t\t\t// Non promise result\n\t\t\tcache[id] = promise;\n\t\t\tconf.emit(\"setasync\", id, 1);\n\t\t\treturn;\n\t\t}\n\t\twaiting[id] = 1;\n\t\tpromises[id] = promise;\n\t\tvar onSuccess = function (result) {\n\t\t\tvar count = waiting[id];\n\t\t\tif (isFailed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Detected unordered then|done & finally resolution, which \" +\n\t\t\t\t\t\t\"in turn makes proper detection of success/failure impossible (when in \" +\n\t\t\t\t\t\t\"'done:finally' mode)\\n\" +\n\t\t\t\t\t\t\"Consider to rely on 'then' or 'done' mode instead.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!count) return; // Deleted from cache before resolved\n\t\t\tdelete waiting[id];\n\t\t\tcache[id] = result;\n\t\t\tconf.emit(\"setasync\", id, count);\n\t\t};\n\t\tvar onFailure = function () {\n\t\t\tisFailed = true;\n\t\t\tif (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\t\t\tdelete waiting[id];\n\t\t\tdelete promises[id];\n\t\t\tconf.delete(id);\n\t\t};\n\n\t\tvar resolvedMode = mode;\n\t\tif (!resolvedMode) resolvedMode = \"then\";\n\n\t\tif (resolvedMode === \"then\") {\n\t\t\tvar nextTickFailure = function () { nextTick(onFailure); };\n\t\t\t// Eventual finally needs to be attached to non rejected promise\n\t\t\t// (so we not force propagation of unhandled rejection)\n\t\t\tpromise = promise.then(function (result) {\n\t\t\t\tnextTick(onSuccess.bind(this, result));\n\t\t\t}, nextTickFailure);\n\t\t\t// If `finally` is a function we attach to it to remove cancelled promises.\n\t\t\tif (typeof promise.finally === \"function\") {\n\t\t\t\tpromise.finally(nextTickFailure);\n\t\t\t}\n\t\t} else if (resolvedMode === \"done\") {\n\t\t\t// Not recommended, as it may mute any eventual \"Unhandled error\" events\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess, onFailure);\n\t\t} else if (resolvedMode === \"done:finally\") {\n\t\t\t// The only mode with no side effects assuming library does not throw unconditionally\n\t\t\t// for rejected promises.\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (typeof promise.finally !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'finally' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess);\n\t\t\tpromise.finally(onFailure);\n\t\t}\n\t});\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id, args, context) {\n\t\tvar promise;\n\t\tif (waiting[id]) {\n\t\t\t++waiting[id]; // Still waiting\n\t\t\treturn;\n\t\t}\n\t\tpromise = promises[id];\n\t\tvar emit = function () { conf.emit(\"getasync\", id, args, context); };\n\t\tif (isPromise(promise)) {\n\t\t\tif (typeof promise.done === \"function\") promise.done(emit);\n\t\t\telse {\n\t\t\t\tpromise.then(function () { nextTick(emit); });\n\t\t\t}\n\t\t} else {\n\t\t\temit();\n\t\t}\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tdelete promises[id];\n\t\tif (waiting[id]) {\n\t\t\tdelete waiting[id];\n\t\t\treturn; // Not yet resolved\n\t\t}\n\t\tif (!hasOwnProperty.call(cache, id)) return;\n\t\tvar result = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, [result]);\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\twaiting = create(null);\n\t\tpromises = create(null);\n\t\tconf.emit(\"clearasync\", objectMap(oldCache, function (data) { return [data]; }));\n\t});\n};\n"],"mappings":"AAAA;;AAEA;;AAEA,YAAY;;AAEZ,IAAIA,SAAS,GAAOC,OAAO,CAAC,oBAAoB,CAAC;EAC7CC,YAAY,GAAID,OAAO,CAAC,8BAA8B,CAAC;EACvDE,YAAY,GAAIF,OAAO,CAAC,6CAA6C,CAAC;EACtEG,aAAa,GAAGH,OAAO,CAAC,wCAAwC,CAAC;EACjEI,SAAS,GAAOJ,OAAO,CAAC,YAAY,CAAC;EACrCK,QAAQ,GAAQL,OAAO,CAAC,WAAW,CAAC;AAExC,IAAIM,MAAM,GAAGC,MAAM,CAACD,MAAM;EACtBE,cAAc,GAAGP,YAAY,CAAC,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,cAAc,CAAC;AAEjFD,OAAO,CAAC,8BAA8B,CAAC,CAACS,OAAO,GAAG,UAAUC,IAAI,EAAEC,IAAI,EAAE;EACvE,IAAIC,OAAO,GAAGN,MAAM,CAAC,IAAI,CAAC;IAAEO,KAAK,GAAGP,MAAM,CAAC,IAAI,CAAC;IAAEQ,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;EAEzE,IAAII,IAAI,KAAK,IAAI,EAAE;IAClBA,IAAI,GAAG,IAAI;EACZ,CAAC,MAAM;IACNA,IAAI,GAAGR,YAAY,CAACQ,IAAI,CAAC;IACzB,IAAI,CAACF,cAAc,CAACE,IAAI,CAAC,EAAE;MAC1B,MAAM,IAAIK,SAAS,CAAC,GAAG,GAAGZ,aAAa,CAACO,IAAI,CAAC,GAAG,6BAA6B,CAAC;IAC/E;EACD;;EAEA;EACAC,IAAI,CAACK,EAAE,CAAC,KAAK,EAAE,UAAUC,EAAE,EAAEC,MAAM,EAAET,OAAO,EAAE;IAC7C,IAAIU,QAAQ,GAAG,KAAK;IAEpB,IAAI,CAACf,SAAS,CAACK,OAAO,CAAC,EAAE;MACxB;MACAI,KAAK,CAACI,EAAE,CAAC,GAAGR,OAAO;MACnBE,IAAI,CAACS,IAAI,CAAC,UAAU,EAAEH,EAAE,EAAE,CAAC,CAAC;MAC5B;IACD;IACAL,OAAO,CAACK,EAAE,CAAC,GAAG,CAAC;IACfH,QAAQ,CAACG,EAAE,CAAC,GAAGR,OAAO;IACtB,IAAIY,SAAS,GAAG,SAAAA,CAAUC,MAAM,EAAE;MACjC,IAAIC,KAAK,GAAGX,OAAO,CAACK,EAAE,CAAC;MACvB,IAAIE,QAAQ,EAAE;QACb,MAAM,IAAIK,KAAK,CACd,2EAA2E,GAC1E,wEAAwE,GACxE,wBAAwB,GACxB,oDACF,CAAC;MACF;MACA,IAAI,CAACD,KAAK,EAAE,OAAO,CAAC;MACpB,OAAOX,OAAO,CAACK,EAAE,CAAC;MAClBJ,KAAK,CAACI,EAAE,CAAC,GAAGK,MAAM;MAClBX,IAAI,CAACS,IAAI,CAAC,UAAU,EAAEH,EAAE,EAAEM,KAAK,CAAC;IACjC,CAAC;IACD,IAAIE,SAAS,GAAG,SAAAA,CAAA,EAAY;MAC3BN,QAAQ,GAAG,IAAI;MACf,IAAI,CAACP,OAAO,CAACK,EAAE,CAAC,EAAE,OAAO,CAAC;MAC1B,OAAOL,OAAO,CAACK,EAAE,CAAC;MAClB,OAAOH,QAAQ,CAACG,EAAE,CAAC;MACnBN,IAAI,CAACe,MAAM,CAACT,EAAE,CAAC;IAChB,CAAC;IAED,IAAIU,YAAY,GAAGjB,IAAI;IACvB,IAAI,CAACiB,YAAY,EAAEA,YAAY,GAAG,MAAM;IAExC,IAAIA,YAAY,KAAK,MAAM,EAAE;MAC5B,IAAIC,eAAe,GAAG,SAAAA,CAAA,EAAY;QAAEvB,QAAQ,CAACoB,SAAS,CAAC;MAAE,CAAC;MAC1D;MACA;MACAhB,OAAO,GAAGA,OAAO,CAACoB,IAAI,CAAC,UAAUP,MAAM,EAAE;QACxCjB,QAAQ,CAACgB,SAAS,CAACS,IAAI,CAAC,IAAI,EAAER,MAAM,CAAC,CAAC;MACvC,CAAC,EAAEM,eAAe,CAAC;MACnB;MACA,IAAI,OAAOnB,OAAO,CAACsB,OAAO,KAAK,UAAU,EAAE;QAC1CtB,OAAO,CAACsB,OAAO,CAACH,eAAe,CAAC;MACjC;IACD,CAAC,MAAM,IAAID,YAAY,KAAK,MAAM,EAAE;MACnC;MACA,IAAI,OAAOlB,OAAO,CAACuB,IAAI,KAAK,UAAU,EAAE;QACvC,MAAM,IAAIR,KAAK,CACd,8DAA8D,GAC7D,gBACF,CAAC;MACF;MACAf,OAAO,CAACuB,IAAI,CAACX,SAAS,EAAEI,SAAS,CAAC;IACnC,CAAC,MAAM,IAAIE,YAAY,KAAK,cAAc,EAAE;MAC3C;MACA;MACA,IAAI,OAAOlB,OAAO,CAACuB,IAAI,KAAK,UAAU,EAAE;QACvC,MAAM,IAAIR,KAAK,CACd,8DAA8D,GAC7D,wBACF,CAAC;MACF;MACA,IAAI,OAAOf,OAAO,CAACsB,OAAO,KAAK,UAAU,EAAE;QAC1C,MAAM,IAAIP,KAAK,CACd,iEAAiE,GAChE,wBACF,CAAC;MACF;MACAf,OAAO,CAACuB,IAAI,CAACX,SAAS,CAAC;MACvBZ,OAAO,CAACsB,OAAO,CAACN,SAAS,CAAC;IAC3B;EACD,CAAC,CAAC;;EAEF;EACAd,IAAI,CAACK,EAAE,CAAC,KAAK,EAAE,UAAUC,EAAE,EAAEgB,IAAI,EAAEC,OAAO,EAAE;IAC3C,IAAIzB,OAAO;IACX,IAAIG,OAAO,CAACK,EAAE,CAAC,EAAE;MAChB,EAAEL,OAAO,CAACK,EAAE,CAAC,CAAC,CAAC;MACf;IACD;IACAR,OAAO,GAAGK,QAAQ,CAACG,EAAE,CAAC;IACtB,IAAIG,IAAI,GAAG,SAAAA,CAAA,EAAY;MAAET,IAAI,CAACS,IAAI,CAAC,UAAU,EAAEH,EAAE,EAAEgB,IAAI,EAAEC,OAAO,CAAC;IAAE,CAAC;IACpE,IAAI9B,SAAS,CAACK,OAAO,CAAC,EAAE;MACvB,IAAI,OAAOA,OAAO,CAACuB,IAAI,KAAK,UAAU,EAAEvB,OAAO,CAACuB,IAAI,CAACZ,IAAI,CAAC,CAAC,KACtD;QACJX,OAAO,CAACoB,IAAI,CAAC,YAAY;UAAExB,QAAQ,CAACe,IAAI,CAAC;QAAE,CAAC,CAAC;MAC9C;IACD,CAAC,MAAM;MACNA,IAAI,CAAC,CAAC;IACP;EACD,CAAC,CAAC;;EAEF;EACAT,IAAI,CAACK,EAAE,CAAC,QAAQ,EAAE,UAAUC,EAAE,EAAE;IAC/B,OAAOH,QAAQ,CAACG,EAAE,CAAC;IACnB,IAAIL,OAAO,CAACK,EAAE,CAAC,EAAE;MAChB,OAAOL,OAAO,CAACK,EAAE,CAAC;MAClB,OAAO,CAAC;IACT;;IACA,IAAI,CAACkB,cAAc,CAACC,IAAI,CAACvB,KAAK,EAAEI,EAAE,CAAC,EAAE;IACrC,IAAIK,MAAM,GAAGT,KAAK,CAACI,EAAE,CAAC;IACtB,OAAOJ,KAAK,CAACI,EAAE,CAAC;IAChBN,IAAI,CAACS,IAAI,CAAC,aAAa,EAAEH,EAAE,EAAE,CAACK,MAAM,CAAC,CAAC;EACvC,CAAC,CAAC;;EAEF;EACAX,IAAI,CAACK,EAAE,CAAC,OAAO,EAAE,YAAY;IAC5B,IAAIqB,QAAQ,GAAGxB,KAAK;IACpBA,KAAK,GAAGP,MAAM,CAAC,IAAI,CAAC;IACpBM,OAAO,GAAGN,MAAM,CAAC,IAAI,CAAC;IACtBQ,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;IACvBK,IAAI,CAACS,IAAI,CAAC,YAAY,EAAErB,SAAS,CAACsC,QAAQ,EAAE,UAAUC,IAAI,EAAE;MAAE,OAAO,CAACA,IAAI,CAAC;IAAE,CAAC,CAAC,CAAC;EACjF,CAAC,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}