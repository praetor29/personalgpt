{"ast":null,"code":"\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\nexports.__esModule = true;\nexports.buildMethodCb = exports.buildCb = exports.getPrComplete = exports.isRunning = exports.cancelAllQueuedCalls = exports.getQueuedCallCount = exports.buildMethod = exports.build = exports.createGroupRef = void 0;\n// @denoify-line-ignore\nvar WeakMap_1 = require(\"minimal-polyfills/WeakMap\");\nvar ExecQueue = /** @class */function () {\n  function ExecQueue() {\n    this.queuedCalls = [];\n    this.isRunning = false;\n    this.prComplete = Promise.resolve();\n  }\n  //TODO: move where it is used.\n  ExecQueue.prototype.cancelAllQueuedCalls = function () {\n    var n;\n    this.queuedCalls.splice(0, n = this.queuedCalls.length);\n    return n;\n  };\n  return ExecQueue;\n}();\nvar globalContext = {};\nvar clusters = new WeakMap_1.Polyfill();\n//console.log(\"Map version\");\n//export const clusters = new Map<Object, Map<GroupRef,ExecQueue>>();\nfunction getOrCreateExecQueue(context, groupRef) {\n  var execQueueByGroup = clusters.get(context);\n  if (!execQueueByGroup) {\n    execQueueByGroup = new WeakMap_1.Polyfill();\n    clusters.set(context, execQueueByGroup);\n  }\n  var execQueue = execQueueByGroup.get(groupRef);\n  if (!execQueue) {\n    execQueue = new ExecQueue();\n    execQueueByGroup.set(groupRef, execQueue);\n  }\n  return execQueue;\n}\nfunction createGroupRef() {\n  return new Array(0);\n}\nexports.createGroupRef = createGroupRef;\nfunction build() {\n  var inputs = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    inputs[_i] = arguments[_i];\n  }\n  switch (inputs.length) {\n    case 1:\n      return buildFnPromise(true, createGroupRef(), inputs[0]);\n    case 2:\n      return buildFnPromise(true, inputs[0], inputs[1]);\n  }\n}\nexports.build = build;\nfunction buildMethod() {\n  var inputs = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    inputs[_i] = arguments[_i];\n  }\n  switch (inputs.length) {\n    case 1:\n      return buildFnPromise(false, createGroupRef(), inputs[0]);\n    case 2:\n      return buildFnPromise(false, inputs[0], inputs[1]);\n  }\n}\nexports.buildMethod = buildMethod;\n/**\n *\n * Get the number of queued call of a run-exclusive function.\n * Note that if you call a runExclusive function and call this\n * directly after it will return 0 as there is one function call\n * execution ongoing but 0 queued.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *\n * */\nfunction getQueuedCallCount(runExclusiveFunction, classInstanceObject) {\n  var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n  return execQueue ? execQueue.queuedCalls.length : 0;\n}\nexports.getQueuedCallCount = getQueuedCallCount;\n/**\n *\n * Cancel all queued calls of a run-exclusive function.\n * Note that the current running call will not be cancelled.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *\n */\nfunction cancelAllQueuedCalls(runExclusiveFunction, classInstanceObject) {\n  var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n  return execQueue ? execQueue.cancelAllQueuedCalls() : 0;\n}\nexports.cancelAllQueuedCalls = cancelAllQueuedCalls;\n/**\n * Tell if a run-exclusive function has an instance of it's call currently being\n * performed.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nfunction isRunning(runExclusiveFunction, classInstanceObject) {\n  var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n  return execQueue ? execQueue.isRunning : false;\n}\nexports.isRunning = isRunning;\n/**\n * Return a promise that resolve when all the current queued call of a runExclusive functions\n * have completed.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nfunction getPrComplete(runExclusiveFunction, classInstanceObject) {\n  var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n  return execQueue ? execQueue.prComplete : Promise.resolve();\n}\nexports.getPrComplete = getPrComplete;\nvar groupByRunExclusiveFunction = new WeakMap_1.Polyfill();\nfunction getExecQueueByFunctionAndContext(runExclusiveFunction, context) {\n  if (context === void 0) {\n    context = globalContext;\n  }\n  var groupRef = groupByRunExclusiveFunction.get(runExclusiveFunction);\n  if (!groupRef) {\n    throw Error(\"Not a run exclusiveFunction\");\n  }\n  var execQueueByGroup = clusters.get(context);\n  if (!execQueueByGroup) {\n    return undefined;\n  }\n  return execQueueByGroup.get(groupRef);\n}\nfunction buildFnPromise(isGlobal, groupRef, fun) {\n  var execQueue;\n  var runExclusiveFunction = function () {\n    var _this = this;\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      inputs[_i] = arguments[_i];\n    }\n    if (!isGlobal) {\n      if (!(this instanceof Object)) {\n        throw new Error(\"Run exclusive, <this> should be an object\");\n      }\n      execQueue = getOrCreateExecQueue(this, groupRef);\n    }\n    return new Promise(function (resolve, reject) {\n      var onPrCompleteResolve;\n      execQueue.prComplete = new Promise(function (resolve) {\n        return onPrCompleteResolve = function () {\n          return resolve();\n        };\n      });\n      var onComplete = function (result) {\n        onPrCompleteResolve();\n        execQueue.isRunning = false;\n        if (execQueue.queuedCalls.length) {\n          execQueue.queuedCalls.shift()();\n        }\n        if (\"data\" in result) {\n          resolve(result.data);\n        } else {\n          reject(result.reason);\n        }\n      };\n      (function callee() {\n        var _this = this;\n        var inputs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          inputs[_i] = arguments[_i];\n        }\n        if (execQueue.isRunning) {\n          execQueue.queuedCalls.push(function () {\n            return callee.apply(_this, inputs);\n          });\n          return;\n        }\n        execQueue.isRunning = true;\n        try {\n          fun.apply(this, inputs).then(function (data) {\n            return onComplete({\n              data: data\n            });\n          })[\"catch\"](function (reason) {\n            return onComplete({\n              reason: reason\n            });\n          });\n        } catch (error) {\n          onComplete({\n            \"reason\": error\n          });\n        }\n      }).apply(_this, inputs);\n    });\n  };\n  if (isGlobal) {\n    execQueue = getOrCreateExecQueue(globalContext, groupRef);\n  }\n  groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n  return runExclusiveFunction;\n}\nfunction buildCb() {\n  var inputs = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    inputs[_i] = arguments[_i];\n  }\n  switch (inputs.length) {\n    case 1:\n      return buildFnCallback(true, createGroupRef(), inputs[0]);\n    case 2:\n      return buildFnCallback(true, inputs[0], inputs[1]);\n  }\n}\nexports.buildCb = buildCb;\nfunction buildMethodCb() {\n  var inputs = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    inputs[_i] = arguments[_i];\n  }\n  switch (inputs.length) {\n    case 1:\n      return buildFnCallback(false, createGroupRef(), inputs[0]);\n    case 2:\n      return buildFnCallback(false, inputs[0], inputs[1]);\n  }\n}\nexports.buildMethodCb = buildMethodCb;\nfunction buildFnCallback(isGlobal, groupRef, fun) {\n  var execQueue;\n  var runExclusiveFunction = function () {\n    var _this = this;\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      inputs[_i] = arguments[_i];\n    }\n    if (!isGlobal) {\n      if (!(this instanceof Object)) {\n        throw new Error(\"Run exclusive, <this> should be an object\");\n      }\n      execQueue = getOrCreateExecQueue(this, groupRef);\n    }\n    var callback = undefined;\n    if (inputs.length && typeof inputs[inputs.length - 1] === \"function\") {\n      callback = inputs.pop();\n    }\n    var onPrCompleteResolve;\n    execQueue.prComplete = new Promise(function (resolve) {\n      return onPrCompleteResolve = function () {\n        return resolve();\n      };\n    });\n    var onComplete = function () {\n      var inputs = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n      }\n      onPrCompleteResolve();\n      execQueue.isRunning = false;\n      if (execQueue.queuedCalls.length) {\n        execQueue.queuedCalls.shift()();\n      }\n      if (callback) {\n        callback.apply(_this, inputs);\n      }\n    };\n    onComplete.hasCallback = !!callback;\n    (function callee() {\n      var _this = this;\n      var inputs = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n      }\n      if (execQueue.isRunning) {\n        execQueue.queuedCalls.push(function () {\n          return callee.apply(_this, inputs);\n        });\n        return;\n      }\n      execQueue.isRunning = true;\n      try {\n        fun.apply(this, __spreadArrays(inputs, [onComplete]));\n      } catch (error) {\n        error.message += \" ( This exception should not have been thrown, miss use of run-exclusive buildCb )\";\n        throw error;\n      }\n    }).apply(this, inputs);\n  };\n  if (isGlobal) {\n    execQueue = getOrCreateExecQueue(globalContext, groupRef);\n  }\n  groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n  return runExclusiveFunction;\n}","map":{"version":3,"names":["WeakMap_1","require","ExecQueue","queuedCalls","isRunning","prComplete","Promise","resolve","prototype","cancelAllQueuedCalls","n","splice","length","globalContext","clusters","Polyfill","getOrCreateExecQueue","context","groupRef","execQueueByGroup","get","set","execQueue","createGroupRef","Array","exports","build","inputs","_i","arguments","buildFnPromise","buildMethod","getQueuedCallCount","runExclusiveFunction","classInstanceObject","getExecQueueByFunctionAndContext","getPrComplete","groupByRunExclusiveFunction","Error","undefined","isGlobal","fun","_this","Object","reject","onPrCompleteResolve","onComplete","result","shift","data","reason","callee","push","apply","then","error","buildCb","buildFnCallback","buildMethodCb","callback","pop","hasCallback","__spreadArrays","message"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\run-exclusive-npm-2.2.19-e6b91092ef-10c0.zip\\node_modules\\run-exclusive\\src\\lib\\runExclusive.ts"],"sourcesContent":["// @denoify-line-ignore\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\n\nclass ExecQueue {\n\n    public readonly queuedCalls: Function[]=[];\n\n    public isRunning: boolean= false;\n\n    //TODO: move where it is used.\n    public cancelAllQueuedCalls(): number {\n\n        let n: number;\n\n        this.queuedCalls.splice(0, n=this.queuedCalls.length);\n\n        return n;\n\n    }\n\n    public prComplete: Promise<void>= Promise.resolve();\n\n\n}\n\n\nconst globalContext: Object = {};\n\nconst clusters = new WeakMap<Object, WeakMap<GroupRef,ExecQueue>>();\n\n//console.log(\"Map version\");\n//export const clusters = new Map<Object, Map<GroupRef,ExecQueue>>();\n\n\nfunction getOrCreateExecQueue(\n    context: Object, \n    groupRef: GroupRef\n): ExecQueue {\n\n    let execQueueByGroup = clusters.get(context);\n\n    if (!execQueueByGroup) {\n        execQueueByGroup = new WeakMap();\n        clusters.set(context, execQueueByGroup);\n    }\n\n    let execQueue= execQueueByGroup.get(groupRef);\n\n    if (!execQueue){\n        execQueue= new ExecQueue();\n        execQueueByGroup.set(groupRef, execQueue);\n    }\n\n    return execQueue;\n\n}\n\nexport type GroupRef = never[];\n\nexport function createGroupRef(): GroupRef {\n    return new Array<never>(0);\n}\n\n/**\n * Built a run-exclusive function from a function that return a promise.\n */\nexport function build<T extends (...input: any[]) => Promise<any>>(fun: T): T;\n/**\n * Built a run-exclusive function from a function that return a promise.\n * \n * The group ref parameter is used when in need that two or more different functions do nor run simultaneously.\n * Group refs are created by calling createGroupRef().\n */\nexport function build<T extends (...input: any[]) => Promise<any>>(groupRef: GroupRef, fun: T): T;\nexport function build(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnPromise(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(true, inputs[0], inputs[1]);\n    }\n\n}\n\n\n/** Same as build but to restrict the exclusion to a class instance object. */\nexport function buildMethod<T extends (...input: any[]) => Promise<any>>(fun: T): T;\nexport function buildMethod<T extends (...input: any[]) => Promise<any>>(groupRef: GroupRef, fun: T): T;\nexport function buildMethod(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnPromise(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(false, inputs[0], inputs[1]);\n    }\n\n}\n\n/** \n * \n * Get the number of queued call of a run-exclusive function. \n * Note that if you call a runExclusive function and call this \n * directly after it will return 0 as there is one function call\n * execution ongoing but 0 queued.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *  \n * */\nexport function getQueuedCallCount(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): number {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.queuedCalls.length:0;\n\n}\n\n/**\n * \n * Cancel all queued calls of a run-exclusive function.\n * Note that the current running call will not be cancelled.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n * \n */\nexport function cancelAllQueuedCalls(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): number {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.cancelAllQueuedCalls():0;\n\n}\n\n/**\n * Tell if a run-exclusive function has an instance of it's call currently being\n * performed.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nexport function isRunning(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): boolean {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.isRunning:false;\n\n}\n\n/**\n * Return a promise that resolve when all the current queued call of a runExclusive functions\n * have completed.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nexport function getPrComplete(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): Promise<void>{\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.prComplete:Promise.resolve();\n\n}\n\nconst groupByRunExclusiveFunction= new WeakMap<Function, GroupRef>();\n\nfunction getExecQueueByFunctionAndContext(\n    runExclusiveFunction: Function,\n    context = globalContext\n): ExecQueue | undefined {\n\n    const groupRef= groupByRunExclusiveFunction.get(runExclusiveFunction);\n\n    if( !groupRef ){\n        throw Error(\"Not a run exclusiveFunction\");\n    }\n\n    const execQueueByGroup= clusters.get(context);\n\n    if( !execQueueByGroup ){\n        return undefined;\n    }\n\n    return execQueueByGroup.get(groupRef)!;\n\n}\n\n\nfunction buildFnPromise<T extends (...inputs: any[]) => Promise<any>>(\n    isGlobal: boolean,\n    groupRef: GroupRef,\n    fun: T\n): T {\n\n    let execQueue: ExecQueue;\n\n    const runExclusiveFunction = (function (this: any, ...inputs) {\n\n        if (!isGlobal) {\n\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n\n            execQueue = getOrCreateExecQueue(this, groupRef);\n\n        }\n\n        return new Promise<any>((resolve, reject) => {\n\n            let onPrCompleteResolve: () => void;\n\n            execQueue.prComplete = new Promise(resolve =>\n                onPrCompleteResolve = () => resolve()\n            );\n\n            const onComplete = (result: { data: any } | { reason: any }) => {\n\n                onPrCompleteResolve();\n\n                execQueue.isRunning = false;\n\n                if (execQueue.queuedCalls.length) {\n                    execQueue.queuedCalls.shift()!();\n                }\n\n                if (\"data\" in result) {\n                    resolve(result.data);\n                } else {\n                    reject(result.reason);\n                }\n\n            };\n\n            (function callee(this: any,...inputs: any[]) {\n\n                if (execQueue.isRunning) {\n                    execQueue.queuedCalls.push(() => callee.apply(this, inputs));\n                    return;\n                }\n\n                execQueue.isRunning = true;\n\n                try {\n\n                    fun.apply(this, inputs)\n                        .then(data => onComplete({ data }))\n                        .catch(reason => onComplete({ reason }))\n                        ;\n\n                } catch (error) {\n\n                    onComplete({ \"reason\": error });\n\n                }\n\n            }).apply(this, inputs);\n\n        });\n\n    }) as T;\n\n    if (isGlobal) {\n\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n\n    }\n\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n\n    return runExclusiveFunction;\n\n}\n\n/** \n * (Read all before using)\n * \n * The pending of 'build' for creating run exclusive functions that complete\n * via calling a callback function. (Instead of returning a promise).\n * \n * The only valid reason to use this instead of ``build()`` is to be able to\n * retrieve the result and/or release the lock synchronously when it's possible.\n * \n * If you want the callback to be optional it is possible to \n * define the function as such:   \n * ``const myRunExclusiveFunction = buildCb((callback?)=> { ... });``  \n * Anyway you must call it every time and assume it has been defined:\n * ``callback!(...)``.   \n * \n * To see if the user has actually provided a callback you can access the hidden property\n * ``callback.hasCallback``.\n * \n * WARNING: You must also make sure, if you use an optional callback \n * that the argument before it cannot be a function.   \n * Be aware that the compiler won't warn you against it.  \n * Example: ``(getLetter:()=> string, callback?:(res:string)=> void)=>{..}``  \n * is NOT a valid function to pass to ``buildCb()`` \n * \n * WARNING: the source function should NEVER throw exception!\n */\nexport function buildCb<T extends (...input: any[]) => void>(fun: T): T;\nexport function buildCb<T extends (...input: any[]) => void>(groupRef: GroupRef, fun: T): T;\nexport function buildCb(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnCallback(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(true, inputs[0], inputs[1]);\n    }\n\n}\n\n/** \n * (Read all before using)\n * \n * Pending of 'buildMethod' for function that return with callback instead of promise.\n * \n * The pending of 'build' for creating run exclusive functions that complete\n * via calling a callback function. (Instead of returning a promise).\n * \n * The only valid reason to use this instead of ``build()`` is to be able to\n * retrieve the result and/or release the lock synchronously when it's possible.\n * \n * If you want the callback to be optional it is possible to \n * define the function as such:   \n * ``const myRunExclusiveFunction = buildCb((callback?)=> { ... });``  \n * Anyway you must call it every time and assume it has been defined:\n * ``callback!(...)``.   \n * \n * To see if the user has actually provided a callback you can access the hidden property\n * ``callback.hasCallback``.\n * \n * WARNING: You must also make sure, if you use an optional callback \n * that the argument before it cannot be a function.   \n * Be aware that the compiler won't warn you against it.  \n * Example: ``(getLetter:()=> string, callback?:(res:string)=> void)=>{..}``  \n * is NOT a valid function to pass to ``buildMethodCb()``\n * \n * WARNING: the source function should NEVER throw exception!\n * \n */\nexport function buildMethodCb<T extends (...input: any[]) => void>(fun: T): T;\nexport function buildMethodCb<T extends (...input: any[]) => void>(groupRef: GroupRef, fun: T): T;\nexport function buildMethodCb(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnCallback(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(false, inputs[0], inputs[1]);\n    }\n\n}\n\nfunction buildFnCallback<T extends (...inputs: any[]) => Promise<any>>(\n    isGlobal: boolean,\n    groupRef: GroupRef,\n    fun: T\n): T {\n\n    let execQueue: ExecQueue;\n\n    const runExclusiveFunction = (function (this: any,...inputs) {\n\n\n        if (!isGlobal) {\n\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n\n            execQueue = getOrCreateExecQueue(this, groupRef);\n\n        }\n\n        let callback: Function | undefined = undefined;\n\n        if (inputs.length && typeof inputs[inputs.length - 1] === \"function\") {\n            callback = inputs.pop();\n        }\n\n        let onPrCompleteResolve: () => void;\n\n        execQueue.prComplete = new Promise(resolve =>\n            onPrCompleteResolve = () => resolve()\n        );\n\n        const onComplete = (...inputs: any[]) => {\n            \n            onPrCompleteResolve();\n\n            execQueue!.isRunning = false;\n\n            if (execQueue.queuedCalls.length) {\n                execQueue.queuedCalls.shift()!();\n            }\n\n            if (callback) {\n                callback.apply(this, inputs);\n            }\n\n        };\n\n        (onComplete as any).hasCallback = !!callback;\n\n        (function callee(this: any, ...inputs: any[]) {\n\n            if (execQueue.isRunning) {\n                execQueue.queuedCalls.push(() => callee.apply(this, inputs));\n                return;\n            }\n\n            execQueue.isRunning = true;\n\n            try {\n\n                fun.apply(this, [...inputs, onComplete]);\n\n            } catch (error) {\n\n                error.message += \" ( This exception should not have been thrown, miss use of run-exclusive buildCb )\";\n\n                throw error;\n\n            }\n\n        }).apply(this, inputs);\n\n    }) as T;\n\n    if (isGlobal) {\n\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n\n    }\n\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n\n    return runExclusiveFunction;\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}