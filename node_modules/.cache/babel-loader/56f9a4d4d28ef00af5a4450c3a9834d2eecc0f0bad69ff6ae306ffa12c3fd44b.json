{"ast":null,"code":"import { __rest, __assign, __spreadArray, __read } from 'tslib';\nimport { complex } from 'style-value-types';\nimport { isNumericalString } from '../../utils/is-numerical-string.js';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.js';\nimport { motionValue } from '../../value/index.js';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.js';\nimport { findValueType } from '../dom/value-types/find.js';\nimport { resolveVariant } from './variants.js';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n    _b = _a.transitionEnd,\n    transitionEnd = _b === void 0 ? {} : _b;\n  _a.transition;\n  var target = __rest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __assign(__assign({}, target), transitionEnd);\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();\n  reversedLabels.forEach(function (key) {\n    var _a;\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b, _c;\n  var _d;\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n    if (value === undefined || value === null) continue;\n    if (typeof value === \"string\" && isNumericalString(value)) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n    visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n  var origin = {};\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n  return origin;\n}\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };","map":{"version":3,"names":["__rest","__assign","__spreadArray","__read","complex","isNumericalString","resolveFinalValueInKeyframes","motionValue","getAnimatableNone","findValueType","resolveVariant","setMotionValue","visualElement","key","value","hasValue","getValue","set","addValue","setTarget","definition","resolved","_a","makeTargetAnimatable","_b","transitionEnd","transition","target","setVariants","variantLabels","reversedLabels","reverse","forEach","variant","getVariant","variantChildren","child","setValues","Array","isArray","checkTargetForNewValues","origin","_c","_d","newValueKeys","Object","keys","filter","numNewValues","length","i","targetValue","readValue","undefined","parseFloat","test","setBaseTarget","getOriginFromTransition","valueTransition","from","getOrigin","get"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/render/utils/setters.js"],"sourcesContent":["import { __rest, __assign, __spreadArray, __read } from 'tslib';\nimport { complex } from 'style-value-types';\nimport { isNumericalString } from '../../utils/is-numerical-string.js';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.js';\nimport { motionValue } from '../../value/index.js';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.js';\nimport { findValueType } from '../dom/value-types/find.js';\nimport { resolveVariant } from './variants.js';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved\n        ? visualElement.makeTargetAnimatable(resolved, false)\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = __rest(_a, [\"transitionEnd\", \"transition\"]);\n    target = __assign(__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" && isNumericalString(value)) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}