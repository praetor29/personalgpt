{"ast":null,"code":"import { createMemoryHistory, createHashHistory, createBrowserHistory } from 'history';\nimport { version, createContext, useState, useLayoutEffect, useEffect, createElement, useContext } from 'react';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction typeOf(value) {\n  if (value === null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n  return typeof value;\n}\nfunction getBuildPathDefRouteNameMessage(routeName) {\n  return \"This problem occurred when building the route definition for the \\\"\" + routeName + \"\\\" route.\";\n}\nfunction getBuildPathDefErrorMessage(context) {\n  return [getBuildPathDefRouteNameMessage(context.routeName), \"The path was constructed as `\" + context.rawPath + \"`\"];\n}\nvar TypeRouteError = /*#__PURE__*/buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage\n  },\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage\n  },\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage\n  },\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: function getDetails(context, segment) {\n      var _segment$trailing, _segment$paramId;\n      var leading = segment.leading;\n      var trailing = (_segment$trailing = segment.trailing) != null ? _segment$trailing : \"\";\n      var paramId = (_segment$paramId = segment.paramId) != null ? _segment$paramId : \"\";\n      var invalidCharacters = (leading + trailing).split(\"\").filter(function (character) {\n        return character !== encodeURIComponent(character);\n      });\n      return [].concat(getBuildPathDefErrorMessage(context), [\"The path segment `\" + (leading + paramId + trailing) + \"` has the following invalid characters: \" + invalidCharacters.join(\", \")]);\n    }\n  },\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: function getDetails(context) {\n      return [].concat(getBuildPathDefErrorMessage(context), [\"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\"]);\n    }\n  },\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: function getDetails(context, parameterNames) {\n      return [].concat(getBuildPathDefErrorMessage(context), [\"A single segment of the path included the following parameters: \" + parameterNames, \"Consider using ofType with a customer ValueSerializer for this scenario.\"]);\n    }\n  },\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: function getDetails(context, parameterName) {\n      return [].concat(getBuildPathDefErrorMessage(context), [\"The parameter \\\"\" + parameterName + \"\\\" was used more than once.\"]);\n    }\n  },\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: function getDetails(context, parameterName, leadingText, trailingText) {\n      var messages = getBuildPathDefErrorMessage(context);\n      if (leadingText) {\n        messages.push(\"The parameter \\\"\" + parameterName + \"\\\" cannot be preceded by \\\"\" + leadingText + \"\\\".\");\n      }\n      if (trailingText) {\n        messages.push(\"The parameter \\\"\" + parameterName + \"\\\" cannot be followed by \\\"\" + trailingText + \"\\\".\");\n      }\n      return messages;\n    }\n  },\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails: function getDetails(context, numOptionalTrailingParameterNames) {\n      return [].concat(getBuildPathDefErrorMessage(context), [\"At most one optional/trailing parameter should be given but \" + numOptionalTrailingParameterNames + \" were provided.\"]);\n    }\n  },\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment: {\n    errorCode: 1008,\n    getDetails: getBuildPathDefErrorMessage\n  },\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails: function getDetails(context, unusedParameters) {\n      return [].concat(getBuildPathDefErrorMessage(context), [\"The following parameters were not used: \" + unusedParameters.join(\", \")]);\n    }\n  },\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character: {\n    errorCode: 1010,\n    getDetails: function getDetails(routeName, paramName) {\n      return [getBuildPathDefRouteNameMessage(routeName), \"The $ { } or / character was used in this parameter name: \" + paramName];\n    }\n  },\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names: {\n    errorCode: 1011,\n    getDetails: function getDetails(duplicateParameterNames) {\n      return [\"The following parameter names were used in both the base route definition and the extension: \" + duplicateParameterNames.join(\", \")];\n    }\n  },\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails: function getDetails(_ref) {\n      var context = _ref.context,\n        value = _ref.value,\n        valueName = _ref.valueName,\n        expectedType = _ref.expectedType,\n        actualType = _ref.actualType;\n      return [\"Problem found with your usage of `\" + context + \"`\", \"`\" + valueName + \"` was expected to be of type `\" + (Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType) + \"` but was of type `\" + actualType + \"`\", \"The actual value provided was: \" + (typeOf(value) === \"object\" ? \"\\n\" + JSON.stringify(value, null, 2).split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\") : \"`\" + value + \"`\")];\n    }\n  },\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails: function getDetails(_ref2) {\n      var context = _ref2.context,\n        args = _ref2.args,\n        min = _ref2.min,\n        max = _ref2.max;\n      return [\"Problem found with your usage of `\" + context + \"`\", \"Expected \" + min + (min === max ? \"\" : \" - \" + max) + \" but received \" + args.length + \" argument\" + (args.length === 1 ? \"\" : \"s\")];\n    }\n  },\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided: {\n    errorCode: 1014,\n    getDetails: function getDetails() {\n      return [\"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\"];\n    }\n  },\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails: function getDetails(_ref3) {\n      var context = _ref3.context,\n        array = _ref3.array,\n        min = _ref3.min,\n        max = _ref3.max;\n      return [\"Problem found with your usage of `\" + context + \"`\", \"Expected array to be of length \" + min + (min === max ? \"\" : \" - \" + max) + \" but actual length was \" + array.length];\n    }\n  },\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails: function getDetails(_ref4) {\n      var routeName = _ref4.routeName,\n        unexpectedParameterName = _ref4.unexpectedParameterName,\n        allowedParameterNames = _ref4.allowedParameterNames;\n      return [\"Problem found with your usage of routes.\" + routeName + \"( ... )\", \"Unexpected parameter passed to route builder named \\\"\" + unexpectedParameterName + \"\\\"\", allowedParameterNames.length === 0 ? \"The route does not take any parameters\" : \"This route takes the following parameters: \" + allowedParameterNames.map(function (name) {\n        return \"\\\"\" + name + \"\\\"\";\n      }).join(\", \")];\n    }\n  },\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails: function getDetails(_ref5) {\n      var routeName = _ref5.routeName,\n        missingParameterName = _ref5.missingParameterName;\n      return [\"Problem found with your usage of routes.\" + routeName + \"( ... )\", \"The parameter \\\"\" + missingParameterName + \"\\\" is required but was not provided.\"];\n    }\n  },\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails: function getDetails(baseUrl) {\n      return ['Base URL must start with a forward slash \"/\"', \"The value you provided \\\"\" + baseUrl + \"\\\" does not start with a forward slash.\"];\n    }\n  },\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails: function getDetails(baseUrl) {\n      var invalidCharacters = baseUrl.replace(/\\//g, \"\").split(\"\").filter(function (character) {\n        return character !== encodeURIComponent(character);\n      });\n      return [\"The following characters are invalid: \" + invalidCharacters.join(\", \") + \".\"];\n    }\n  },\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails: function getDetails() {\n      return [\"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\"];\n    }\n  },\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails: function getDetails(version) {\n      return [\"React version must be 16.8 or greater.\", \"You have version \" + version + \" installed.\", \"If you cannot upgrade the React version try using `type-route/core`.\"];\n    }\n  }\n});\nfunction buildErrorCollection(definitions) {\n  var errors = {};\n  Object.keys(definitions).forEach(function (key) {\n    var name = key.replace(/_/g, \" \") + \".\";\n    var _definitions$key = definitions[key],\n      errorCode = _definitions$key.errorCode,\n      getDetails = _definitions$key.getDetails;\n    var messageTitle = \"TR\" + errorCode + \" \\xB7 \" + name;\n    errors[key] = {\n      errorCode: errorCode,\n      name: name,\n      create: function create() {\n        var _getDetails;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var message = ((_getDetails = getDetails == null ? void 0 : getDetails.apply(void 0, args)) != null ? _getDetails : []).map(function (detail) {\n          return \"- \" + detail;\n        }).join(\"\\n\");\n        var error = new Error(message ? \"\\n\\n\" + messageTitle + \"\\n\\n\" + message + \"\\n\" : \"\\n\\n\" + messageTitle + \"\\n\");\n        error.name = \"(hopefully helpful \\uD83D\\uDE04) TypeRouteError\";\n        return error;\n      }\n    };\n  });\n  return errors;\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction assert(context, assertions) {\n  assertions.forEach(function (assert) {\n    return assert(context);\n  });\n}\nassert.arrayLength = function (array, min, max) {\n  if (max === void 0) {\n    max = min;\n  }\n  return function (context) {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create({\n        context: context,\n        array: array,\n        min: min,\n        max: max\n      });\n    }\n  };\n};\nassert.numArgs = function (args, min, max) {\n  if (max === void 0) {\n    max = min;\n  }\n  return function (context) {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create({\n        context: context,\n        args: args,\n        min: min,\n        max: max\n      });\n    }\n  };\n};\nassert.collectionOfType = function (expectedType, valueName, value) {\n  return function (context) {\n    if (typeOf(value) === \"object\") {\n      var valuePropertyNames = Object.keys(value);\n      for (var _i = 0, _valuePropertyNames = valuePropertyNames; _i < _valuePropertyNames.length; _i++) {\n        var propertyName = _valuePropertyNames[_i];\n        assert.type(expectedType, valueName + \".\" + propertyName, value[propertyName])(context);\n      }\n      return;\n    }\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context: context,\n      actualType: typeOf(value),\n      expectedType: \"Record<string, \" + (Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType) + \">\",\n      value: value,\n      valueName: valueName\n    });\n  };\n};\nassert.arrayOfType = function (expectedType, valueName, value) {\n  return function (context) {\n    if (Array.isArray(value)) {\n      for (var index = 0; index < value.length; index++) {\n        assert.type(expectedType, valueName + \"[\" + index + \"]\", value[index])(context);\n      }\n      return;\n    }\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context: context,\n      actualType: typeOf(value),\n      expectedType: \"Array<\" + (Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType) + \">\",\n      value: value,\n      valueName: valueName\n    });\n  };\n};\nassert.type = function (expectedType, valueName, value) {\n  return function (context) {\n    var expectedTypeList = typeof expectedType === \"string\" ? [expectedType] : expectedType;\n    for (var _iterator = _createForOfIteratorHelperLoose(expectedTypeList), _step; !(_step = _iterator()).done;) {\n      var _expectedType = _step.value;\n      var expectsProperType = _expectedType[0].toUpperCase() === _expectedType[0];\n      if (expectsProperType && (typeOf(value) === \"object\" || typeOf(value) === \"function\") && typeOf(value[\"~internal\"]) === \"object\" && value[\"~internal\"].type === _expectedType || !expectsProperType && typeOf(value) === _expectedType) {\n        return;\n      }\n    }\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context: context,\n      actualType: typeOf(value),\n      expectedType: expectedType,\n      value: value,\n      valueName: valueName\n    });\n  };\n};\nfunction buildPathDefs(routeName, pathParamDefCollection, getRawPath) {\n  var namedPathParamDefs = Object.keys(pathParamDefCollection).map(function (paramName) {\n    var namedPathParameterDefinition = _extends({\n      paramName: paramName\n    }, pathParamDefCollection[paramName]);\n    return namedPathParameterDefinition;\n  });\n  var paramIdCollection = {};\n  namedPathParamDefs.forEach(function (_ref) {\n    var paramName = _ref.paramName;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (paramName.indexOf(\"$\") >= 0 || paramName.indexOf(\"{\") >= 0 || paramName.indexOf(\"}\") >= 0 || paramName.indexOf(\"/\") >= 0) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(routeName, paramName);\n      }\n    }\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n  var rawPath = getRawPath(paramIdCollection);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (Array.isArray(rawPath)) {\n      assert(\"ReturnType<\" + routeName + \".path>\", [assert.arrayOfType(\"string\", \"path\", rawPath), assert.arrayLength(rawPath, 1, Infinity)]);\n    } else {\n      assert(\"ReturnType<\" + routeName + \".path>\", [assert.type(\"string\", \"path\", rawPath)]);\n    }\n  }\n  return asArray(rawPath).map(function (rawPath) {\n    var errorContext = {\n      rawPath: rawPath,\n      routeName: routeName\n    };\n    if (process.env.NODE_ENV !== \"production\") {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(errorContext);\n      }\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(errorContext);\n      }\n    }\n    if (rawPath.length === 1) {\n      return [];\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(errorContext);\n      }\n    }\n    var rawPathSegments = rawPath.split(\"/\").slice(1);\n    var usedPathParams = {};\n    var pathDef = [];\n    for (var _iterator = _createForOfIteratorHelperLoose(rawPathSegments), _step; !(_step = _iterator()).done;) {\n      var rawSegment = _step.value;\n      if (process.env.NODE_ENV !== \"production\") {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(errorContext);\n        }\n      }\n      var includedParamDef = null;\n      for (var _iterator2 = _createForOfIteratorHelperLoose(namedPathParamDefs), _step2; !(_step2 = _iterator2()).done;) {\n        var paramDef = _step2.value;\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(errorContext, [paramDef.paramName, includedParamDef.paramName]);\n            }\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(errorContext, paramDef.paramName);\n            }\n          }\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n      if (includedParamDef) {\n        var _rawSegment$split = rawSegment.split(getParamId(includedParamDef.paramName)),\n          leading = _rawSegment$split[0],\n          trailing = _rawSegment$split[1];\n        if (process.env.NODE_ENV !== \"production\") {\n          if (encodeURIComponent(leading) !== leading || encodeURIComponent(trailing) !== trailing) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(errorContext, {\n              leading: leading,\n              paramId: getParamId(includedParamDef.paramName),\n              trailing: trailing\n            });\n          }\n          if (includedParamDef[\"~internal\"].optional && (leading !== \"\" || trailing !== \"\")) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(errorContext, includedParamDef.paramName, leading, trailing);\n          }\n        }\n        pathDef.push({\n          leading: leading,\n          trailing: trailing,\n          namedParamDef: includedParamDef\n        });\n      } else {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(errorContext, {\n              leading: rawSegment\n            });\n          }\n        }\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null\n        });\n      }\n    }\n    var numOptionalOrTrailingParams = pathDef.filter(function (part) {\n      var _part$namedParamDef, _part$namedParamDef2;\n      return ((_part$namedParamDef = part.namedParamDef) == null ? void 0 : _part$namedParamDef[\"~internal\"].optional) || ((_part$namedParamDef2 = part.namedParamDef) == null ? void 0 : _part$namedParamDef2[\"~internal\"].trailing);\n    }).length;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(errorContext, numOptionalOrTrailingParams);\n      }\n    }\n    var lastPathSegmentParameterDefinition = pathDef[pathDef.length - 1].namedParamDef;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (numOptionalOrTrailingParams === 1 && !(lastPathSegmentParameterDefinition != null && lastPathSegmentParameterDefinition[\"~internal\"].optional) && !(lastPathSegmentParameterDefinition != null && lastPathSegmentParameterDefinition[\"~internal\"].trailing)) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(errorContext);\n      }\n    }\n    var unusedPathParameterDefinitions = namedPathParamDefs.map(function (_ref2) {\n      var name = _ref2.paramName;\n      return name;\n    }).filter(function (name) {\n      return !usedPathParams[name];\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(errorContext, unusedPathParameterDefinitions);\n      }\n    }\n    return pathDef;\n  });\n}\nfunction getParamId(parameterName) {\n  return \"${p.\" + parameterName + \"}\";\n}\nfunction getParamDefsOfType(type, paramDefCollection) {\n  var filteredParamDefCollection = {};\n  Object.keys(paramDefCollection).forEach(function (name) {\n    var paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] = paramDef;\n    }\n  });\n  return filteredParamDefCollection;\n}\nfunction createLocation(_ref) {\n  var paramCollection = _ref.paramCollection,\n    paramDefCollection = _ref.paramDefCollection,\n    arraySeparator = _ref.arraySeparator,\n    queryStringSerializer = _ref.queryStringSerializer,\n    pathDefs = _ref.pathDefs,\n    baseUrl = _ref.baseUrl;\n  var params = {\n    path: {},\n    query: {},\n    state: {}\n  };\n  var _loop = function _loop(paramName) {\n    var _paramDef$Internal$v;\n    var paramValue = paramCollection[paramName];\n    if (paramValue === undefined) {\n      return \"continue\";\n    }\n    var paramDef = paramDefCollection[paramName];\n    var urlEncodeDefault = paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    var urlEncode = (_paramDef$Internal$v = paramDef[\"~internal\"].valueSerializer.urlEncode) != null ? _paramDef$Internal$v : urlEncodeDefault;\n    var value = void 0;\n    if (paramDef[\"~internal\"].array) {\n      if (!Array.isArray(paramValue)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n            context: \"routes[routeName](...)\",\n            actualType: typeOf(paramValue),\n            expectedType: \"array\",\n            value: paramValue,\n            valueName: paramName\n          });\n        }\n      }\n      value = paramValue.length === 0 ? null : paramValue.map(function (part) {\n        return stringify(paramDef, part, urlEncode);\n      }).join(arraySeparator);\n    } else {\n      value = stringify(paramDef, paramValue, urlEncode);\n    }\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value: value\n    };\n  };\n  for (var paramName in paramDefCollection) {\n    var _ret = _loop(paramName);\n    if (_ret === \"continue\") continue;\n  }\n  var path = \"/\" + pathDefs[0].filter(function (_ref2) {\n    var namedParamDef = _ref2.namedParamDef;\n    return !(namedParamDef != null && namedParamDef[\"~internal\"].optional && params.path[namedParamDef.paramName] === undefined);\n  }).map(function (_ref3) {\n    var namedParamDef = _ref3.namedParamDef,\n      leading = _ref3.leading,\n      trailing = _ref3.trailing;\n    var rawParam = namedParamDef ? params.path[namedParamDef.paramName].value : \"\";\n    return leading + rawParam + trailing;\n  }).join(\"/\");\n  var hasQueryParams = Object.keys(params.query).length > 0;\n  var query = hasQueryParams ? queryStringSerializer.stringify(params.query) : undefined;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n  var state = Object.keys(params.state).length === 0 ? undefined : Object.keys(params.state).reduce(function (state, key) {\n    var _extends2;\n    return _extends({}, state, (_extends2 = {}, _extends2[key] = params.state[key].value, _extends2));\n  }, {});\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path: path,\n    query: query,\n    state: state\n  };\n}\nfunction stringify(paramDef, value, urlEncode) {\n  var result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n  if (process.env.NODE_ENV !== \"production\") {\n    assert(\"[ValueSerializer].stringify\", [assert.type(\"string\", \"result\", result)]);\n  }\n  return urlEncode ? encodeURIComponent(result) : result;\n}\nvar noMatch = {\n  __noMatch: true\n};\nvar stringUtils = {\n  startsWith: startsWith,\n  endsWith: endsWith,\n  splitFirst: splitFirst\n};\nfunction startsWith(value, start) {\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction endsWith(value, end) {\n  for (var i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction splitFirst(value, split) {\n  var _value$split = value.split(split),\n    first = _value$split[0],\n    rest = _value$split.slice(1);\n  return [first, rest.join(split)];\n}\nvar endsWith$1 = stringUtils.endsWith,\n  startsWith$1 = stringUtils.startsWith;\nfunction getPathMatch(_ref) {\n  var path = _ref.path,\n    pathDefs = _ref.pathDefs,\n    arraySeparator = _ref.arraySeparator;\n  for (var index = 0; index < pathDefs.length; index++) {\n    var result = match(pathDefs[index]);\n    if (result !== false) {\n      return _extends({}, result, {\n        primaryPath: index === 0\n      });\n    }\n  }\n  return false;\n  function match(pathDef) {\n    var params = {};\n    if (path === \"/\" && pathDef.length === 0) {\n      return {\n        params: params,\n        numExtraneousParams: 0\n      };\n    }\n    var pathHasTrailingSlash = path.length > 1 && endsWith$1(path, \"/\");\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n    var pathSegmentList = path.split(\"/\").slice(1);\n    var _loop = function _loop(segmentIndex) {\n      var _pathSegmentDef$named2, _pathSegmentDef$named3;\n      var pathSegmentDef = segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      var pathSegment = segmentIndex >= pathSegmentList.length ? null : pathSegmentList[segmentIndex];\n      if (pathSegmentDef === null) {\n        return {\n          v: false\n        };\n      }\n      var numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n      if (pathSegment === null) {\n        var _pathSegmentDef$named;\n        if (numRemainingPathSegmentDefs !== 0 || !((_pathSegmentDef$named = pathSegmentDef.namedParamDef) != null && _pathSegmentDef$named[\"~internal\"].optional)) {\n          return {\n            v: false\n          };\n        }\n        return \"break\";\n      }\n      if ((_pathSegmentDef$named2 = pathSegmentDef.namedParamDef) != null && _pathSegmentDef$named2[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n      if (!startsWith$1(pathSegment, pathSegmentDef.leading)) {\n        return {\n          v: false\n        };\n      }\n      var pathSegmentMinusLeading = pathSegment.slice(pathSegmentDef.leading.length);\n      if (!endsWith$1(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return {\n          v: false\n        };\n      }\n      var pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(0, pathSegmentMinusLeading.length - pathSegmentDef.trailing.length);\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          return \"continue\";\n        }\n        return {\n          v: false\n        };\n      }\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          return \"continue\";\n        }\n        return {\n          v: false\n        };\n      }\n      var urlEncode = (_pathSegmentDef$named3 = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode) != null ? _pathSegmentDef$named3 : !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n      var value = void 0;\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing.split(arraySeparator).map(function (part) {\n          var _pathSegmentDef$named4;\n          return (_pathSegmentDef$named4 = pathSegmentDef.namedParamDef) == null ? void 0 : _pathSegmentDef$named4[\"~internal\"].valueSerializer.parse(urlEncode ? decodeURIComponent(part) : part);\n        });\n        if (value.some(function (part) {\n          return part === noMatch;\n        })) {\n          return {\n            v: false\n          };\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(urlEncode ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing) : pathSegmentMinusLeadingAndTrailing);\n        if (value === noMatch) {\n          return {\n            v: false\n          };\n        }\n      }\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing && pathHasTrailingSlash && pathSegmentDef.trailing === \"\") {\n        value = value + \"/\";\n      }\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        return \"break\";\n      }\n    };\n    for (var segmentIndex = 0; segmentIndex < Math.max(pathDef.length, pathSegmentList.length); segmentIndex++) {\n      var _ret = _loop(segmentIndex);\n      if (_ret === \"break\") break;\n      if (_ret === \"continue\") continue;\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n    return {\n      params: params,\n      numExtraneousParams: 0\n    };\n  }\n}\nfunction getObjectMatch(_ref) {\n  var object = _ref.object,\n    paramDefs = _ref.paramDefs,\n    urlEncodeDefault = _ref.urlEncodeDefault,\n    arraySeparator = _ref.arraySeparator;\n  var params = {};\n  var namedParamDefs = Object.keys(paramDefs).map(function (name) {\n    return _extends({\n      name: name\n    }, paramDefs[name]);\n  });\n  var extraneousParams = _extends({}, object);\n  var _loop = function _loop() {\n    var paramDef = _step.value;\n    var raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        return \"continue\";\n      }\n      return {\n        v: false\n      };\n    }\n    var value = void 0;\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        return \"continue\";\n      } else {\n        return {\n          v: false\n        };\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map(function (part) {\n        var _paramDef$Internal$v;\n        return paramDef[\"~internal\"].valueSerializer.parse(((_paramDef$Internal$v = paramDef[\"~internal\"].valueSerializer.urlEncode) != null ? _paramDef$Internal$v : urlEncodeDefault) ? decodeURIComponent(part) : part);\n      });\n      if (value.some(function (part) {\n        return part === noMatch;\n      })) {\n        if (paramDef[\"~internal\"].optional) {\n          return \"continue\";\n        }\n        return {\n          v: false\n        };\n      }\n    } else {\n      var _paramDef$Internal$v2;\n      value = paramDef[\"~internal\"].valueSerializer.parse(((_paramDef$Internal$v2 = paramDef[\"~internal\"].valueSerializer.urlEncode) != null ? _paramDef$Internal$v2 : urlEncodeDefault) ? decodeURIComponent(raw) : raw);\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          return \"continue\";\n        }\n        return {\n          v: false\n        };\n      }\n    }\n    params[paramDef.name] = value;\n  };\n  for (var _iterator = _createForOfIteratorHelperLoose(namedParamDefs), _step; !(_step = _iterator()).done;) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n  return {\n    params: params,\n    numExtraneousParams: Object.keys(extraneousParams).length\n  };\n}\nfunction getStateMatch(state, paramDefs, arraySeparator) {\n  return getObjectMatch({\n    object: state != null ? state : {},\n    paramDefs: paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator: arraySeparator\n  });\n}\nfunction getQueryMatch(query, paramDefs, queryStringSerializer, arraySeparator) {\n  var object = {};\n  if (query) {\n    object = queryStringSerializer.parse(query);\n    if (process.env.NODE_ENV !== \"production\") {\n      assert(\"[QueryStringSerializer].parse\", [assert.collectionOfType([\"string\", \"null\"], \"parsedQueryString\", object)]);\n    }\n  }\n  return getObjectMatch({\n    object: object,\n    paramDefs: paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator: arraySeparator\n  });\n}\nfunction createMatcher(_ref) {\n  var pathDefs = _ref.pathDefs,\n    params = _ref.params;\n  var queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  var stateParamDefCollection = getParamDefsOfType(\"state\", params);\n  var defaultParams = {};\n  Object.keys(params).forEach(function (paramName) {\n    var param = params[paramName];\n    if (param[\"~internal\"][\"default\"] === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"][\"default\"];\n  });\n  return function (_ref2) {\n    var routerLocation = _ref2.routerLocation,\n      arraySeparator = _ref2.arraySeparator,\n      queryStringSerializer = _ref2.queryStringSerializer;\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n    var pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs: pathDefs,\n      arraySeparator: arraySeparator\n    });\n    if (pathMatch === false) {\n      return false;\n    }\n    var queryMatch = getQueryMatch(routerLocation.query, queryParamDefCollection, queryStringSerializer, arraySeparator);\n    if (queryMatch === false) {\n      return false;\n    }\n    var stateMatch = getStateMatch(routerLocation.state, stateParamDefCollection, arraySeparator);\n    if (stateMatch === false) {\n      return false;\n    }\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: _extends({}, defaultParams, pathMatch.params, queryMatch.params, stateMatch.params),\n      numExtraneousParams: pathMatch.numExtraneousParams + queryMatch.numExtraneousParams + stateMatch.numExtraneousParams\n    };\n  };\n}\nfunction preventDefaultLinkClickBehavior(event) {\n  if (event === void 0) {\n    event = {};\n  }\n  var e = event;\n  var isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n  var isSelfTarget = !e.target || !e.target.target || e.target.target === \"_self\";\n  if (isSelfTarget &&\n  // Ignore everything but links with target self\n  !e.defaultPrevented &&\n  // onClick prevented default\n  e.button === 0 &&\n  // ignore everything but left clicks\n  !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n    return true;\n  }\n  return false;\n}\nvar startsWith$2 = stringUtils.startsWith;\nfunction buildRoute(_ref) {\n  var routeName = _ref.routeName,\n    params = _ref.params,\n    location = _ref.location,\n    routerContext = _ref.routerContext;\n  var navigate = routerContext.navigate,\n    history = routerContext.history;\n  var href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\"\n  });\n  if (startsWith$2(href, \"#\")) {\n    href = \"/\" + href;\n  }\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n  var route = {\n    name: routeName,\n    params: params,\n    href: href,\n    link: {\n      href: href,\n      onClick: function onClick(event) {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      }\n    },\n    action: null,\n    push: function push() {\n      return navigate(_extends({}, route, {\n        action: \"push\"\n      }), true);\n    },\n    replace: function replace() {\n      return navigate(_extends({}, route, {\n        action: \"replace\"\n      }), true);\n    }\n  };\n  return route;\n}\nfunction createRouteBuilder(routeName, routeDef, getRouterContext) {\n  var pathDefs = buildPathDefs(routeName, getParamDefsOfType(\"path\", routeDef[\"~internal\"].params), routeDef[\"~internal\"].path);\n  var build = function build(params) {\n    if (params === void 0) {\n      params = {};\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      assert(\"routes.\" + routeName, [assert.numArgs([].slice.call(arguments), 0, 1), assert.type(\"object\", \"params\", params)]);\n      for (var paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create({\n            routeName: routeName,\n            unexpectedParameterName: paramKey,\n            allowedParameterNames: Object.keys(routeDef[\"~internal\"].params)\n          });\n        }\n      }\n      for (var _paramKey in routeDef[\"~internal\"].params) {\n        var value = params[_paramKey];\n        var paramDef = routeDef[\"~internal\"].params[_paramKey][\"~internal\"];\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create({\n              routeName: routeName,\n              missingParameterName: _paramKey\n            });\n          }\n          continue;\n        }\n      }\n    }\n    var routerContext = getRouterContext();\n    var arraySeparator = routerContext.arraySeparator,\n      queryStringSerializer = routerContext.queryStringSerializer,\n      baseUrl = routerContext.baseUrl;\n    var paramsWithDefault = _extends({}, params);\n    Object.keys(routeDef[\"~internal\"].params).forEach(function (paramName) {\n      var paramDef = routeDef[\"~internal\"].params[paramName];\n      if (paramsWithDefault[paramName] === undefined && paramDef[\"~internal\"][\"default\"] !== undefined) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"][\"default\"];\n      }\n    });\n    var location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator: arraySeparator,\n      queryStringSerializer: queryStringSerializer,\n      pathDefs: pathDefs,\n      baseUrl: baseUrl\n    });\n    return buildRoute({\n      routeName: routeName,\n      params: paramsWithDefault,\n      location: location,\n      routerContext: routerContext\n    });\n  };\n  Object.defineProperty(build, \"name\", {\n    value: routeName\n  });\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs: pathDefs,\n      params: routeDef[\"~internal\"].params\n    }),\n    pathDefs: pathDefs,\n    Route: null\n  };\n  return build;\n}\nfunction createQueryStringSerializer(args) {\n  var _args$queryStringArra, _args$arraySeparator;\n  if (args === void 0) {\n    args = {};\n  }\n  var queryStringArrayFormat = (_args$queryStringArra = args.queryStringArrayFormat) != null ? _args$queryStringArra : \"singleKeyWithBracket\";\n  var arraySeparator = (_args$arraySeparator = args.arraySeparator) != null ? _args$arraySeparator : \",\";\n  var multiKey = queryStringArrayFormat === \"multiKey\" || queryStringArrayFormat === \"multiKeyWithBracket\";\n  var arrayKeySuffix = queryStringArrayFormat === \"multiKey\" || queryStringArrayFormat === \"singleKey\" ? \"\" : \"[]\";\n  return {\n    parse: function parse(raw) {\n      var queryParams = {};\n      for (var _iterator = _createForOfIteratorHelperLoose(raw.split(\"&\")), _step; !(_step = _iterator()).done;) {\n        var part = _step.value;\n        var _part$split = part.split(\"=\"),\n          rawParamName = _part$split[0],\n          rawParamValue = _part$split[1],\n          rest = _part$split.slice(2);\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n        var key = decodeURIComponent(stringUtils.endsWith(rawParamName, arrayKeySuffix) ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length) : rawParamName);\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += \"\" + arraySeparator + rawParamValue;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n      return queryParams;\n    },\n    stringify: function stringify(queryParams) {\n      return Object.keys(queryParams).map(function (name) {\n        var encodedName = encodeURIComponent(name);\n        var key = queryParams[name].array ? \"\" + encodedName + arrayKeySuffix : encodedName;\n        var value = queryParams[name].value;\n        if (value === null) {\n          return key;\n        }\n        if (queryParams[name].array && multiKey) {\n          var valueParts = value.split(arraySeparator);\n          return valueParts.map(function (part) {\n            return key + \"=\" + part;\n          }).join(\"&\");\n        }\n        return key + \"=\" + value;\n      }).join(\"&\");\n    }\n  };\n}\nfunction getMatchingRoute(location, routerContext) {\n  var getRoutes = routerContext.getRoutes,\n    queryStringSerializer = routerContext.queryStringSerializer,\n    arraySeparator = routerContext.arraySeparator;\n  var routes = getRoutes();\n  var nonExactMatch = false;\n  for (var routeName in routes) {\n    var match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer: queryStringSerializer,\n      arraySeparator: arraySeparator\n    });\n    if (match === false) {\n      continue;\n    }\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath\n      };\n    }\n    if (nonExactMatch === false || match.numExtraneousParams < nonExactMatch.numExtraneousParams) {\n      nonExactMatch = _extends({}, match, {\n        routeName: routeName\n      });\n    }\n  }\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath\n    };\n  }\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location: location,\n      routerContext: routerContext\n    }),\n    primaryPath: true\n  };\n}\nvar startsWith$3 = stringUtils.startsWith;\nfunction convertToRouterLocationFromHistoryLocation(rawLocation, baseUrl) {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith$3(rawLocation.pathname, baseUrl) ? baseUrl !== \"/\" ? rawLocation.pathname.replace(baseUrl, \"\") : rawLocation.pathname : undefined,\n    query: rawLocation.search ? startsWith$3(rawLocation.search, \"?\") ? rawLocation.search.slice(1) : rawLocation.search : undefined,\n    state: typeof rawLocation.state === \"object\" && rawLocation.state !== null ? rawLocation.state.state : undefined\n  };\n}\nvar splitFirst$1 = stringUtils.splitFirst;\nfunction getRouteByHref(href, state, routerContext) {\n  var _splitFirst = splitFirst$1(href, \"?\"),\n    pathname = _splitFirst[0],\n    search = _splitFirst[1];\n  var location = convertToRouterLocationFromHistoryLocation({\n    pathname: pathname,\n    search: search,\n    state: state\n  }, routerContext.baseUrl);\n  return getMatchingRoute(location, routerContext);\n}\nfunction createNavigationHandlerManager(_ref) {\n  var startListening = _ref.startListening,\n    stopListening = _ref.stopListening;\n  var handlerIdList = [];\n  var idCounter = 0;\n  return {\n    add: add,\n    getHandlers: getHandlers\n  };\n  function getHandlers() {\n    return handlerIdList.map(function (_ref2) {\n      var handler = _ref2.handler;\n      return handler;\n    });\n  }\n  function add(handler) {\n    var id = idCounter++;\n    handlerIdList.push({\n      id: id,\n      handler: handler\n    });\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n    return remove;\n    function remove() {\n      var index = handlerIdList.map(function (_ref3) {\n        var id = _ref3.id;\n        return id;\n      }).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\nfunction attemptScrollToTop(route, scrollToTop) {\n  if (route.action === \"push\" && typeof window === \"object\" && window !== null && typeof window.scroll === \"function\" && scrollToTop !== false && typeof navigator === \"object\" && navigator !== null && typeof navigator.userAgent === \"string\" && !(navigator.userAgent.indexOf(\"Node.js\") > 0 || navigator.userAgent.indexOf(\"jsdom\") > 0)) {\n    try {\n      window.scroll(0, 0);\n    } catch (_unused) {}\n  }\n}\nfunction serializeStateParams(route, routeDefs) {\n  var state = {};\n  if (route.name) {\n    var sortedParams = Object.keys(route.params).sort();\n    for (var _iterator = _createForOfIteratorHelperLoose(sortedParams), _step; !(_step = _iterator()).done;) {\n      var paramName = _step.value;\n      var paramDef = routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n      if (paramDef.kind === \"state\") {\n        var value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n  return state;\n}\nvar startsWith$4 = stringUtils.startsWith,\n  splitFirst$2 = stringUtils.splitFirst;\nfunction createRouter() {\n  var _opts$baseUrl, _opts$arrayFormat$sep, _opts$arrayFormat, _opts$queryStringSeri, _opts$arrayFormat2;\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var _parseArgs = parseArgs(args),\n    routeDefs = _parseArgs.routeDefs,\n    opts = _parseArgs.opts;\n  var navigationHandlerManager = createNavigationHandlerManager({\n    startListening: function startListening() {\n      unlisten = history.listen(function (update) {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n        var location = convertToRouterLocationFromHistoryLocation(update.location, baseUrl);\n        var action = update.action.toLowerCase();\n        var _getMatchingRoute = getMatchingRoute(location, getRouterContext()),\n          route = _getMatchingRoute.route,\n          primaryPath = _getMatchingRoute.primaryPath;\n        handleNavigation(_extends({}, route, {\n          action: action\n        }), primaryPath);\n      });\n    },\n    stopListening: function stopListening() {\n      return unlisten == null ? void 0 : unlisten();\n    }\n  });\n  var baseUrl = (_opts$baseUrl = opts.baseUrl) != null ? _opts$baseUrl : \"/\";\n  var arraySeparator = (_opts$arrayFormat$sep = (_opts$arrayFormat = opts.arrayFormat) == null ? void 0 : _opts$arrayFormat.separator) != null ? _opts$arrayFormat$sep : \",\";\n  var queryStringSerializer = (_opts$queryStringSeri = opts.queryStringSerializer) != null ? _opts$queryStringSeri : createQueryStringSerializer({\n    queryStringArrayFormat: (_opts$arrayFormat2 = opts.arrayFormat) == null ? void 0 : _opts$arrayFormat2.queryString,\n    arraySeparator: arraySeparator\n  });\n  var history;\n  var unlisten;\n  var skipNextEnvironmentTriggeredNavigation = false;\n  var skipHandlingNextApplicationTriggeredNavigation = false;\n  var initialRoute = null;\n  var previousRoute = null;\n  var blockerCollection = [];\n  applySessionOpts(opts.session);\n  var routes = createRouteBuilderCollection(getRouterContext);\n  var router = {\n    routes: routes,\n    session: {\n      push: function push(href, state) {\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].push\", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type(\"string\", \"href\", href), assert.type([\"object\", \"undefined\"], \"state\", state)]);\n        }\n        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),\n          route = _getRouteByHref.route,\n          primaryPath = _getRouteByHref.primaryPath;\n        return navigate(_extends({}, route, {\n          action: \"push\"\n        }), primaryPath);\n      },\n      replace: function replace(href, state) {\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].replace\", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type(\"string\", \"href\", href), assert.type([\"object\", \"undefined\"], \"state\", state)]);\n        }\n        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),\n          route = _getRouteByHref2.route,\n          primaryPath = _getRouteByHref2.primaryPath;\n        return navigate(_extends({}, route, {\n          action: \"replace\"\n        }), primaryPath);\n      },\n      back: function back(amount) {\n        if (amount === void 0) {\n          amount = 1;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].back\", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type(\"number\", \"amount\", amount)]);\n        }\n        history.go(-amount);\n      },\n      forward: function forward(amount) {\n        if (amount === void 0) {\n          amount = 1;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].forward\", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type(\"number\", \"amount\", amount)]);\n        }\n        history.go(amount);\n      },\n      getInitialRoute: function getInitialRoute() {\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [assert.numArgs([].slice.call(arguments), 0)]);\n        }\n        if (!initialRoute) {\n          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());\n          }\n          initialRoute = result.route;\n        }\n        return initialRoute;\n      },\n      reset: function reset(session) {\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[RouterSessionHistory].reset\", [assert.numArgs([].slice.call(arguments), 1), assert.type(\"object\", \"session\", session)]);\n        }\n        return applySessionOpts(session);\n      },\n      block: function block(blocker) {\n        blockerCollection.push(blocker);\n        var unblock = history.block(function (update) {\n          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),\n            route = _getMatchingRoute2.route;\n          var action = update.action.toLowerCase();\n          blocker({\n            route: _extends({}, route, {\n              action: action\n            }),\n            retry: update.retry\n          });\n        });\n        return function () {\n          blockerCollection.splice(blockerCollection.findIndex(function (item) {\n            return item === blocker;\n          }), 1);\n          unblock();\n        };\n      },\n      listen: function listen(handler) {\n        return navigationHandlerManager.add(handler);\n      }\n    }\n  };\n  return router;\n  function applySessionOpts(sessionOpts) {\n    if (sessionOpts === void 0) {\n      sessionOpts = {\n        type: typeof window !== \"undefined\" && typeof window.document !== \"undefined\" ? \"browser\" : \"memory\"\n      };\n    }\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window\n      });\n    }\n  }\n  function navigate(route, primaryPath) {\n    var _previousRoute;\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach(function (blocker) {\n        blocker({\n          route: route,\n          retry: function retry() {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          }\n        });\n      });\n      return;\n    }\n    var state = serializeStateParams(route, routeDefs);\n    if (((_previousRoute = previousRoute) == null ? void 0 : _previousRoute.href) === route.href && JSON.stringify(serializeStateParams(previousRoute, routeDefs)) === JSON.stringify(state)) {\n      return;\n    }\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n    skipNextEnvironmentTriggeredNavigation = true;\n    var _splitFirst = splitFirst$2(route.href, \"?\"),\n      pathname = _splitFirst[0],\n      search = _splitFirst[1];\n    history[route.action === \"replace\" ? \"replace\" : \"push\"]({\n      pathname: pathname,\n      search: search ? \"?\" + search : \"\",\n      hash: \"\"\n    }, state ? {\n      state: state\n    } : undefined);\n  }\n  function handleNavigation(route, primaryPath) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n    for (var _iterator = _createForOfIteratorHelperLoose(navigationHandlerManager.getHandlers()), _step; !(_step = _iterator()).done;) {\n      var handler = _step.value;\n      handler(route);\n    }\n    attemptScrollToTop(route, opts.scrollToTop);\n    previousRoute = route;\n  }\n  function getRouterContext() {\n    return {\n      queryStringSerializer: queryStringSerializer,\n      arraySeparator: arraySeparator,\n      navigate: navigate,\n      history: history,\n      routeDefs: routeDefs,\n      getRoutes: function getRoutes() {\n        return routes;\n      },\n      baseUrl: baseUrl\n    };\n  }\n}\nfunction parseArgs(args) {\n  var routeDefs = args.length === 1 ? args[0] : args[1];\n  var opts = args.length === 1 ? {} : args[0];\n  if (process.env.NODE_ENV !== \"production\") {\n    var _opts$arrayFormat3;\n    assert(\"createRouter\", [assert.numArgs(args, 1, 2), assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs), assert.type(\"object\", \"opts\", opts)]);\n    if ((_opts$arrayFormat3 = opts.arrayFormat) != null && _opts$arrayFormat3.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith$4(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(opts.baseUrl);\n      }\n      if (opts.baseUrl.split(\"/\").some(function (part) {\n        return encodeURIComponent(part) !== part;\n      })) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(opts.baseUrl);\n      }\n    }\n  }\n  return {\n    routeDefs: routeDefs,\n    opts: opts\n  };\n}\nfunction createRouteBuilderCollection(getRouterContext) {\n  var routes = {};\n  var _getRouterContext = getRouterContext(),\n    routeDefs = _getRouterContext.routeDefs;\n  for (var routeName in routeDefs) {\n    var routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(routeName, routeDef, getRouterContext);\n  }\n  return routes;\n}\nfunction defineRoute() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n  var parent = parseArgs$1(args);\n  var routeDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path\n    },\n    extend: function extend() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n      var _parseArgs = parseArgs$1(args),\n        params = _parseArgs.params,\n        path = _parseArgs.path;\n      var parentParamNames = Object.keys(parent.params);\n      var extensionParamNames = Object.keys(params);\n      var duplicateParamNames = parentParamNames.filter(function (name) {\n        return extensionParamNames.indexOf(name) >= 0;\n      });\n      if (process.env.NODE_ENV !== \"production\") {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(duplicateParamNames);\n        }\n      }\n      return defineRoute(_extends({}, params, parent.params), function (x) {\n        var _ref;\n        var parentPathArray = asArray(parent.path(filter(parentParamNames)));\n        var childPathArray = asArray(path(filter(extensionParamNames)));\n        return (_ref = []).concat.apply(_ref, parentPathArray.map(function (parentPath) {\n          return childPathArray.map(function (childPath) {\n            if (parentPath === \"/\") {\n              return childPath;\n            }\n            return parentPath + (childPath === \"/\" ? \"\" : childPath);\n          });\n        }));\n        function filter(allowedKeys) {\n          var filteredX = {};\n          allowedKeys.forEach(function (key) {\n            filteredX[key] = x[key];\n          });\n          return filteredX;\n        }\n      });\n    }\n  };\n  return routeDef;\n}\nfunction assertDefineRouteOrExtendArgs(functionName, args) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [assert.numArgs(args, 1, 2), assert.collectionOfType(\"ParamDef\", \"params\", args[0]), assert.type(\"function\", \"path\", args[1])]);\n    }\n  }\n}\nfunction parseArgs$1(args) {\n  return args.length === 1 ? {\n    params: {},\n    path: function path() {\n      return args[0];\n    }\n  } : {\n    params: args[0],\n    path: args[1]\n  };\n}\nvar _boolean = {\n  id: \"boolean\",\n  parse: function parse(raw) {\n    return raw === \"true\" ? true : raw === \"false\" ? false : noMatch;\n  },\n  stringify: function stringify(value) {\n    return value ? \"true\" : \"false\";\n  }\n};\nvar number = {\n  id: \"number\",\n  parse: function parse(raw) {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n    return parseFloat(raw);\n  },\n  stringify: function stringify(value) {\n    return value.toString();\n  }\n};\nfunction isNumeric(value) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\nvar string = {\n  id: \"string\",\n  parse: function parse(raw) {\n    return raw;\n  },\n  stringify: function stringify(value) {\n    return value;\n  }\n};\nvar json = function json() {\n  var valueSerializer = {\n    id: \"json\",\n    parse: function parse(raw) {\n      var value;\n      try {\n        value = JSON.parse(raw);\n      } catch (_unused) {\n        return noMatch;\n      }\n      return value;\n    },\n    stringify: function stringify(value) {\n      return JSON.stringify(value);\n    }\n  };\n  return valueSerializer;\n};\nvar param = {\n  path: /*#__PURE__*/_extends({}, /*#__PURE__*/getParamDefKindSection(\"path\", false), {\n    trailing: /*#__PURE__*/getParamDefKindSection(\"path\", true)\n  }),\n  query: /*#__PURE__*/getParamDefKindSection(\"query\", false),\n  state: /*#__PURE__*/getParamDefKindSection(\"state\", false)\n};\nfunction getParamDefKindSection(kind, trailing) {\n  return _extends({}, getParamDefOptionalitySection(false, false), {\n    array: getParamDefOptionalitySection(false, true),\n    optional: _extends({}, getParamDefOptionalitySection(true, false), {\n      array: getParamDefOptionalitySection(true, true)\n    })\n  });\n  function getParamDefOptionalitySection(optional, array) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array: array,\n          kind: kind,\n          optional: optional,\n          valueSerializer: string,\n          trailing: trailing,\n          \"default\": undefined\n        }\n      }),\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array: array,\n          kind: kind,\n          optional: optional,\n          valueSerializer: number,\n          trailing: trailing,\n          \"default\": undefined\n        }\n      }),\n      \"boolean\": getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array: array,\n          kind: kind,\n          optional: optional,\n          valueSerializer: _boolean,\n          trailing: trailing,\n          \"default\": undefined\n        }\n      }),\n      ofType: function ofType(valueSerializer) {\n        if (valueSerializer === void 0) {\n          valueSerializer = json();\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[ParamDef].ofType\", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type(\"object\", \"valueSerializer\", valueSerializer)]);\n        }\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array: array,\n            kind: kind,\n            optional: optional,\n            valueSerializer: valueSerializer,\n            trailing: trailing,\n            \"default\": undefined\n          }\n        });\n      }\n    };\n  }\n  function getParamDef(_ref) {\n    var internal = _ref[\"~internal\"];\n    if (!internal.optional) {\n      return {\n        \"~internal\": internal\n      };\n    }\n    return {\n      \"~internal\": internal,\n      \"default\": function _default(value) {\n        if (process.env.NODE_ENV !== \"production\") {\n          assert(\"[ParamDef].default\", [assert.numArgs([].slice.call(arguments), 1)]);\n        }\n        return {\n          \"~internal\": _extends({}, internal, {\n            \"default\": value\n          })\n        };\n      }\n    };\n  }\n}\nfunction createGroup(groupItems) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assert(\"createGroup\", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType([\"RouteGroup\", \"RouteBuilder\"], \"groupItems\", groupItems)]);\n  }\n  var routeNames = {};\n  groupItems.forEach(function (item) {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach(function (name) {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null\n    },\n    routeNames: Object.keys(routeNames),\n    has: function has(route) {\n      if (process.env.NODE_ENV !== \"production\") {\n        assert(\"[RouteGroup].has\", [assert.numArgs([].slice.call(arguments), 1), assert.type(\"object\", \"route\", route)]);\n      }\n      if (route.name === false) {\n        return false;\n      }\n      return !!routeNames[route.name];\n    }\n  };\n}\nfunction isRouteGroup(value) {\n  return !!value.routeNames;\n}\nif (typeof (process.env.NODE_ENV !== \"production\") === \"boolean\" && process.env.NODE_ENV !== \"production\") {\n  var _React$version$split$ = /*#__PURE__*/version.split(\".\").map(function (value) {\n      return parseInt(value, 10);\n    }),\n    major = _React$version$split$[0],\n    minor = _React$version$split$[1];\n  if (major < 16 || major === 16 && minor < 8) {\n    throw TypeRouteError.Invalid_React_version.create(version);\n  }\n}\nfunction createRouter$1() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var _parseArgs = parseArgs(args),\n    opts = _parseArgs.opts,\n    routeDefs = _parseArgs.routeDefs;\n  var router = createRouter(_extends({}, opts, {\n    scrollToTop: false\n  }), routeDefs);\n  var routeContext = createContext(null);\n  return _extends({}, router, {\n    RouteProvider: RouteProvider,\n    useRoute: useRoute\n  });\n  function RouteProvider(props) {\n    var _React$useState = useState(router.session.getInitialRoute()),\n      route = _React$useState[0],\n      setRoute = _React$useState[1];\n    useLayoutEffect(function () {\n      return router.session.listen(setRoute);\n    }, []);\n    useEffect(function () {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n    return createElement(routeContext.Provider, {\n      value: route\n    }, props.children);\n  }\n  function useRoute() {\n    var route = useContext(routeContext);\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n    return route;\n  }\n}\nexport { createGroup, createRouter$1 as createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };","map":{"version":3,"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","_expectedType","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","paramValue","undefined","urlEncodeDefault","urlEncode","_paramDef$Internal$v","valueSerializer","valueSerializerId","id","_ret","_loop","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","endsWith$1","startsWith$1","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","_pathSegmentDef$named2","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named3","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","startsWith$2","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","_paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","startsWith$3","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst$1","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","startsWith$4","splitFirst$2","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","parseArgs$1","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","_boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has","_React$version$split$","parseInt","major","minor","createRouter$1","routeContext","createContext","RouteProvider","useRoute","props","_React$useState","useState","setRoute","useLayoutEffect","useEffect","createElement","Provider","children","useContext"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\typeOf.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\TypeRouteError.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\asArray.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\assert.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\buildPathDefs.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getParamDefsOfType.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createLocation.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\noMatch.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\stringUtils.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getPathMatch.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getObjectMatch.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getStateMatch.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getQueryMatch.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createMatcher.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\preventDefaultLinkClickBehavior.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\buildRoute.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createRouteBuilder.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createQueryStringSerializer.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getMatchingRoute.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\convertToRouterLocationFromHistoryLocation.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\getRouteByHref.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createNavigationHandlerManager.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\attemptScrollToTop.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\serializeStateParams.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createRouter.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\defineRoute.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\param.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\createGroup.ts","C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\type-route-npm-0.7.2-f14d32ed44-10c0.zip\\node_modules\\type-route\\src\\react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    let value: string | null;\n\n    if (paramDef[\"~internal\"].array) {\n      if (!Array.isArray(paramValue)) {\n        if (__DEV__) {\n          throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n            context: \"routes[routeName](...)\",\n            actualType: typeOf(paramValue),\n            expectedType: \"array\",\n            value: paramValue,\n            valueName: paramName,\n          });\n        }\n      }\n\n      value =\n        (paramValue as unknown[]).length === 0\n          ? null\n          : (paramValue as unknown[])\n              .map((part) => stringify(paramDef, part, urlEncode))\n              .join(arraySeparator);\n    } else {\n      value = stringify(paramDef, paramValue, urlEncode);\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://zilch.dev/type-route/docs/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://zilch.dev/type-route/docs/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}