{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n        layoutReady = _b.layoutReady,\n        parent = _b.parent;\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\n           * After all children have started animating, ensure any Entering components are set to Present.\n           * If we add deferred animations (set up all animations and then start them in two loops) this\n           * could be moved to the start loop. But it needs to happen after all the animations configs\n           * are generated in AnimateSharedLayout as this relies on presence data\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n           * we ensure there's no flash.\n           */\n          flushSync.preRender();\n          flushSync.render();\n        });\n        read(function () {\n          /**\n           * Schedule a callback at the end of the following frame to assign the latest projection\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n           * child attempts to calculate its previous relative position against a prevViewportBox\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\n           * render.\n           */\n          sync.postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      });\n      // TODO: Need to find a layout-synchronous way of flushing this\n      flushLayout();\n    }\n  };\n}\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\nexport { createBatcher };","map":{"version":3,"names":["__spreadArray","__read","sync","flushSync","collectProjectingAncestors","updateLayoutMeasurement","batchLayout","flushLayout","compareByDepth","Presence","defaultHandler","layoutReady","child","notifyLayoutReady","createBatcher","queue","Set","add","flush","_a","_b","parent","read","write","order","Array","from","sort","ancestors","allElements","forEach","element","resetTransform","restoreTransform","isPresent","presence","Present","preRender","render","postRender","assignProjectionToSnapshot","clear","prevViewportBox","projection","target"],"sources":["C:/Users/prana/repos/personalgpt/.yarn/__virtual__/framer-motion-virtual-4606bf46ad/3/AppData/Local/Yarn/Berry/cache/framer-motion-npm-4.1.17-00d2b9950f-10c0.zip/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js"],"sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    flushSync.preRender();\n                    flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync.postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}