{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Evt = exports.onAddHandlerByEvt = void 0;\n// @denoify-line-ignore\nrequire(\"minimal-polyfills/Array.prototype.find\");\n// @denoify-line-ignore\nvar Map_1 = require(\"minimal-polyfills/Map\");\n// @denoify-line-ignore\nvar WeakMap_1 = require(\"minimal-polyfills/WeakMap\");\nvar importProxy_1 = require(\"./importProxy\");\nvar Evt_create_1 = require(\"./Evt.create\");\nvar Evt_getCtx_1 = require(\"./Evt.getCtx\");\nvar Evt_factorize_1 = require(\"./Evt.factorize\");\nvar Evt_merge_1 = require(\"./Evt.merge\");\nvar Evt_from_1 = require(\"./Evt.from\");\nvar Evt_asPostable_1 = require(\"./Evt.asPostable\");\nvar Evt_asyncPipe_1 = require(\"./Evt.asyncPipe\");\nvar Evt_asNonPostable_1 = require(\"./Evt.asNonPostable\");\nvar Evt_parsePropsFromArgs_1 = require(\"./Evt.parsePropsFromArgs\");\nvar Evt_newCtx_1 = require(\"./Evt.newCtx\");\nvar LazyEvt_1 = require(\"./LazyEvt\");\nvar runExclusive = __importStar(require(\"run-exclusive\"));\nvar overwriteReadonlyProp_1 = require(\"tsafe/lab/overwriteReadonlyProp\");\nvar typeGuard_1 = require(\"tsafe/typeGuard\");\nvar Deferred_1 = require(\"../tools/Deferred\");\nvar Evt_loosenType_1 = require(\"./Evt.loosenType\");\nvar safeSetTimeout_1 = require(\"../tools/safeSetTimeout\");\nvar isPromiseLike_1 = require(\"tsafe/isPromiseLike\");\nvar EvtError_1 = require(\"./types/EvtError\");\nvar nsCtxLike = __importStar(require(\"./types/interfaces/CtxLike\"));\nvar convertOperatorToStatelessFLambda_1 = require(\"./util/convertOperatorToStatelessFLambda\");\nvar runSideEffect = function (sideEffect) {\n  return sideEffect();\n};\n// NOTE: For compat with --no-check \n// https://github.com/asos-craigmorten/opine/issues/97#issuecomment-751806014\nvar CtxLikeAsValue = nsCtxLike.CtxLike;\nvar EvtImpl = /** @class */function () {\n  function EvtImpl() {\n    this.lazyEvtAttach = new LazyEvt_1.LazyEvt();\n    this.lazyEvtDetach = new LazyEvt_1.LazyEvt();\n    this.__maxHandlers = undefined;\n    this.postCount = 0;\n    this.traceId = null;\n    this.handlers = [];\n    this.handlerTriggers = new Map_1.Polyfill();\n    /*\n    NOTE: Used as Date.now() would be used to compare if an event is anterior\n    or posterior to an other. We don't use Date.now() because two call within\n    less than a ms will return the same value unlike this function.\n    */\n    this.__currentChronologyMark = 0;\n    this.asyncHandlerCount = 0;\n  }\n  EvtImpl.setDefaultMaxHandlers = function (n) {\n    this.__defaultMaxHandlers = isFinite(n) ? n : 0;\n  };\n  EvtImpl.prototype.toStateful = function (p1, p2) {\n    var isP1Ctx = CtxLikeAsValue.match(p1);\n    var initialValue = isP1Ctx ? undefined : p1;\n    var ctx = p2 || (isP1Ctx ? p1 : undefined);\n    var out = new importProxy_1.importProxy.StatefulEvt(initialValue);\n    var callback = function (data) {\n      return out.post(data);\n    };\n    if (!!ctx) {\n      this.attach(ctx, callback);\n    } else {\n      this.attach(callback);\n    }\n    return out;\n  };\n  Object.defineProperty(EvtImpl.prototype, \"evtAttach\", {\n    get: function () {\n      return this.lazyEvtAttach.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EvtImpl.prototype, \"evtDetach\", {\n    get: function () {\n      return this.lazyEvtDetach.evt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  EvtImpl.prototype.setMaxHandlers = function (n) {\n    this.__maxHandlers = isFinite(n) ? n : 0;\n    return this;\n  };\n  EvtImpl.prototype.enableTrace = function (params\n  //NOTE: Not typeof console.log as we don't want to expose types from node\n  ) {\n    var id = params.id,\n      formatter = params.formatter,\n      log = params.log;\n    this.traceId = id;\n    this.traceFormatter = formatter || function (data) {\n      try {\n        return JSON.stringify(data, null, 2);\n      } catch (_a) {\n        return \"\".concat(data);\n      }\n    };\n    this.log = log === undefined ? function () {\n      var inputs = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n      }\n      return console.log.apply(console, __spreadArray([], __read(inputs), false));\n    } : log === false ? undefined : log;\n  };\n  EvtImpl.prototype.disableTrace = function () {\n    this.traceId = null;\n    return this;\n  };\n  Object.defineProperty(EvtImpl.prototype, \"asyncHandlerChronologyMark\", {\n    //NOTE: An async handler ( attached with waitFor ) is only eligible to handle a post if the post\n    //occurred after the handler was set. We don't want to waitFor event from the past.\n    //private readonly asyncHandlerChronologyMark = new WeakMap<ImplicitParams.Async, number>();\n    get: function () {\n      var _a, _b;\n      var _c, _d;\n      return (_b = (_d = (_a = (_c = this)[\"~internal\"]) !== null && _a !== void 0 ? _a : _c[\"~internal\"] = {})[\"asyncHandlerChronologyMark\"]) !== null && _b !== void 0 ? _b : _d[\"asyncHandlerChronologyMark\"] = new WeakMap_1.Polyfill();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EvtImpl.prototype, \"asyncHandlerChronologyExceptionRange\", {\n    //NOTE: There is an exception to the above rule, we want to allow async waitFor loop \n    //do so we have to handle the case where multiple event would be posted synchronously.\n    get: function () {\n      var _a, _b;\n      var _c, _d;\n      return (_b = (_d = (_a = (_c = this)[\"~internal\"]) !== null && _a !== void 0 ? _a : _c[\"~internal\"] = {})[\"asyncHandlerChronologyExceptionRange\"]) !== null && _b !== void 0 ? _b : _d[\"asyncHandlerChronologyExceptionRange\"] = new WeakMap_1.Polyfill();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EvtImpl.prototype, \"invocableOpByOp\", {\n    get: function () {\n      var _a, _b;\n      var _c, _d;\n      return (_b = (_d = (_a = (_c = this)[\"~internal\"]) !== null && _a !== void 0 ? _a : _c[\"~internal\"] = {})[\"invocableOpByOp\"]) !== null && _b !== void 0 ? _b : _d[\"invocableOpByOp\"] = new WeakMap_1.Polyfill();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  EvtImpl.prototype.getInvocableOp = function (op) {\n    var invocableOp = this.invocableOpByOp.get(op);\n    if (invocableOp === undefined) {\n      throw new Error([\"Provided operator isn't the operator of any handler\", \"currently attached to the Evt instance\"].join(\" \"));\n    }\n    return invocableOp;\n  };\n  EvtImpl.prototype.getChronologyMark = function () {\n    return this.__currentChronologyMark++;\n  };\n  EvtImpl.prototype.detachHandler = function (handler, wTimer, rejectPr) {\n    var index = this.handlers.indexOf(handler);\n    if (index < 0) {\n      return false;\n    }\n    if ((0, typeGuard_1.typeGuard)(handler, !!handler.ctx)) {\n      handler.ctx.zz__removeHandler(handler);\n    }\n    this.handlers.splice(index, 1);\n    if (handler.async) {\n      this.asyncHandlerCount--;\n    }\n    this.handlerTriggers.delete(handler);\n    if (wTimer[0] !== undefined) {\n      (0, safeSetTimeout_1.safeClearTimeout)(wTimer[0]);\n      rejectPr(new EvtError_1.DetachedEvtError());\n    }\n    this.lazyEvtDetach.post(handler);\n    return true;\n  };\n  EvtImpl.prototype.triggerHandler = function (handler, wTimer, resolvePr, opResult //TODO: Or readonly [ any ] ?? \n  ) {\n    var callback = handler.callback,\n      once = handler.once;\n    if (wTimer[0] !== undefined) {\n      (0, safeSetTimeout_1.safeClearTimeout)(wTimer[0]);\n      wTimer[0] = undefined;\n    }\n    if (once) {\n      handler.detach();\n    }\n    var _a = __read(opResult, 1),\n      transformedData = _a[0];\n    var prOrValue = callback === null || callback === void 0 ? void 0 : callback.call(this, transformedData);\n    resolvePr === null || resolvePr === void 0 ? void 0 : resolvePr(transformedData);\n    return (0, isPromiseLike_1.isPromiseLike)(prOrValue) ? prOrValue : undefined;\n  };\n  EvtImpl.prototype.addHandler = function (propsFromArgs, propsFromMethodName) {\n    var _this_1 = this;\n    var _a;\n    this.invocableOpByOp.set(propsFromArgs.op, (0, convertOperatorToStatelessFLambda_1.convertOperatorToStatelessFλ)(propsFromArgs.op));\n    var d = new Deferred_1.Deferred();\n    var wTimer = [undefined];\n    var handler = __assign(__assign(__assign({}, propsFromArgs), propsFromMethodName), {\n      \"detach\": function () {\n        return _this_1.detachHandler(handler, wTimer, d.reject);\n      },\n      \"promise\": d.pr\n    });\n    if (typeof handler.timeout === \"number\") {\n      wTimer[0] = (0, safeSetTimeout_1.safeSetTimeout)(function () {\n        wTimer[0] = undefined;\n        handler.detach();\n        d.reject(new EvtError_1.TimeoutEvtError(handler.timeout));\n      }, handler.timeout);\n    }\n    var handlerTrigger = function (opResult) {\n      return _this_1.triggerHandler(handler, wTimer, d.isPending ? d.resolve : undefined, opResult);\n    };\n    this.handlerTriggers.set(handler, handlerTrigger);\n    if (handler.async) {\n      this.asyncHandlerChronologyMark.set(handler, this.getChronologyMark());\n    }\n    if (handler.prepend) {\n      var i = void 0;\n      for (i = 0; i < this.handlers.length; i++) {\n        if (this.handlers[i].extract) {\n          continue;\n        }\n        break;\n      }\n      this.handlers.splice(i, 0, handler);\n    } else {\n      this.handlers.push(handler);\n    }\n    if (handler.async) {\n      this.asyncHandlerCount++;\n    }\n    this.checkForPotentialMemoryLeak();\n    if ((0, typeGuard_1.typeGuard)(handler, !!handler.ctx)) {\n      handler.ctx.zz__addHandler(handler, this);\n    }\n    (_a = exports.onAddHandlerByEvt.get(this)) === null || _a === void 0 ? void 0 : _a(handler, handlerTrigger);\n    //NOTE: Can happen for example if this is a StatefulEvt \n    //and the handler is \"once\" and the matcher match the state \n    //We don't want to post an attach if the handler is already detached.\n    if (this.handlerTriggers.has(handler)) {\n      this.lazyEvtAttach.post(handler);\n    }\n    return handler;\n  };\n  EvtImpl.prototype.checkForPotentialMemoryLeak = function () {\n    var maxHandlers = this.__maxHandlers !== undefined ? this.__maxHandlers : EvtImpl.__defaultMaxHandlers;\n    if (maxHandlers === 0 || this.handlers.length % (maxHandlers + 1) !== 0) {\n      return;\n    }\n    var message = [\"MaxHandlersExceededWarning: Possible Evt memory leak detected.\", \"\".concat(this.handlers.length, \" handlers attached\").concat(this.traceId ? \" to \\\"\".concat(this.traceId, \"\\\"\") : \"\", \".\\n\"), \"Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\\n\", \"Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to \".concat(EvtImpl.__defaultMaxHandlers, \".\\n\")].join(\"\");\n    var map = new Map_1.Polyfill();\n    this.getHandlers().map(function (_a) {\n      var ctx = _a.ctx,\n        async = _a.async,\n        once = _a.once,\n        prepend = _a.prepend,\n        extract = _a.extract,\n        op = _a.op,\n        callback = _a.callback;\n      return __assign(__assign({\n        \"hasCtx\": !!ctx,\n        once: once,\n        prepend: prepend,\n        extract: extract,\n        \"isWaitFor\": async\n      }, op === Evt_parsePropsFromArgs_1.matchAll ? {} : {\n        \"op\": op.toString()\n      }), !callback ? {} : {\n        \"callback\": callback.toString()\n      });\n    }).map(function (obj) {\n      return \"{\\n\" + Object.keys(obj).map(function (key) {\n        return \"  \".concat(key, \": \").concat(obj[key]);\n      }).join(\",\\n\") + \"\\n}\";\n    }).forEach(function (str) {\n      return map.set(str, (map.has(str) ? map.get(str) : 0) + 1);\n    });\n    message += \"\\n\" + Array.from(map.keys()).map(function (str) {\n      return \"\".concat(map.get(str), \" handler\").concat(map.get(str) === 1 ? \"\" : \"s\", \" like:\\n\").concat(str);\n    }).join(\"\\n\") + \"\\n\";\n    if (this.traceId === null) {\n      message += \"\\n\" + [\"To validate the identify of the Evt instance that is triggering this warning you can call\", \"Evt.prototype.enableTrace({ \\\"id\\\": \\\"My evt id\\\", \\\"log\\\": false }) on the Evt that you suspect.\\n\"].join(\" \");\n    }\n    try {\n      console.warn(message);\n    } catch (_a) {}\n  };\n  EvtImpl.prototype.isHandledByOp = function (op, data) {\n    var hasSideEffect = false;\n    var invocableOp;\n    try {\n      invocableOp = this.getInvocableOp(op);\n    } catch (_a) {\n      return false;\n    }\n    var opResult = invocableOp(data, function () {\n      return hasSideEffect = true;\n    });\n    return opResult !== null || hasSideEffect;\n  };\n  EvtImpl.prototype.trace = function (data) {\n    var _this_1 = this;\n    var _a;\n    if (this.traceId === null) {\n      return;\n    }\n    var message = \"(\".concat(this.traceId, \") \");\n    var isExtracted = !!this.handlers.find(function (_a) {\n      var extract = _a.extract,\n        op = _a.op;\n      return extract && _this_1.isHandledByOp(op, data);\n    });\n    if (isExtracted) {\n      message += \"extracted \";\n    } else {\n      var handlerCount = this.handlers.filter(function (_a) {\n        var extract = _a.extract,\n          op = _a.op;\n        return !extract && _this_1.isHandledByOp(op, data);\n      }).length;\n      message += \"\".concat(handlerCount, \" handler\").concat(handlerCount > 1 ? \"s\" : \"\", \", \");\n    }\n    (_a = this.log) === null || _a === void 0 ? void 0 : _a.call(this, message + this.traceFormatter(data));\n  };\n  /** Return [ isExtracted, prAllHandlerCallbacksResolved ] */\n  EvtImpl.prototype.postSync = function (data) {\n    var e_1, _a;\n    var prAllHandlerCallbacksResolved = [];\n    var getReturnValue = function (isExtracted) {\n      return [isExtracted, Promise.all(prAllHandlerCallbacksResolved).then(function () {})];\n    };\n    try {\n      for (var _b = __values(__spreadArray([], __read(this.handlers), false)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var handler = _c.value;\n        var async = handler.async,\n          op = handler.op,\n          extract = handler.extract;\n        if (async) {\n          continue;\n        }\n        //NOTE: If detached while executing the operator\n        //we still want to trigger the handler.\n        var handlerTrigger = this.handlerTriggers.get(handler);\n        var opResult = this.getInvocableOp(op)(data, runSideEffect);\n        if (opResult === null) {\n          continue;\n        }\n        //NOTE: Possible if detached while in the loop.\n        if (!handlerTrigger) {\n          continue;\n        }\n        var prOrUndefined = handlerTrigger(opResult);\n        if (prOrUndefined !== undefined) {\n          prAllHandlerCallbacksResolved.push(prOrUndefined);\n        }\n        if (extract) {\n          return getReturnValue(true);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return getReturnValue(false);\n  };\n  EvtImpl.prototype.postAsyncFactory = function () {\n    var _this_1 = this;\n    return runExclusive.buildMethodCb(function (data, postChronologyMark, releaseLock) {\n      var e_2, _a;\n      if (_this_1.asyncHandlerCount === 0) {\n        releaseLock();\n        return;\n      }\n      var promises = [];\n      var chronologyMarkStartResolveTick;\n      //NOTE: Must be before handlerTrigger call.\n      Promise.resolve().then(function () {\n        return chronologyMarkStartResolveTick = _this_1.getChronologyMark();\n      });\n      var _loop_1 = function (handler) {\n        if (!handler.async) {\n          return \"continue\";\n        }\n        var opResult = _this_1.getInvocableOp(handler.op)(data, runSideEffect);\n        if (opResult === null) {\n          return \"continue\";\n        }\n        var handlerTrigger = _this_1.handlerTriggers.get(handler);\n        if (!handlerTrigger) {\n          return \"continue\";\n        }\n        var shouldCallHandlerTrigger = function () {\n          var handlerMark = _this_1.asyncHandlerChronologyMark.get(handler);\n          if (postChronologyMark > handlerMark) {\n            return true;\n          }\n          var exceptionRange = _this_1.asyncHandlerChronologyExceptionRange.get(handler);\n          return exceptionRange !== undefined && exceptionRange.lowerMark < postChronologyMark && postChronologyMark < exceptionRange.upperMark && handlerMark > exceptionRange.upperMark;\n        }();\n        if (!shouldCallHandlerTrigger) {\n          return \"continue\";\n        }\n        promises.push(new Promise(function (resolve) {\n          return handler.promise.then(function () {\n            return resolve();\n          }).catch(function () {\n            return resolve();\n          });\n        }));\n        handlerTrigger(opResult);\n      };\n      try {\n        for (var _b = __values(__spreadArray([], __read(_this_1.handlers), false)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var handler = _c.value;\n          _loop_1(handler);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      if (promises.length === 0) {\n        releaseLock();\n        return;\n      }\n      var handlersDump = __spreadArray([], __read(_this_1.handlers), false);\n      Promise.all(promises).then(function () {\n        var e_3, _a;\n        try {\n          for (var _b = __values(_this_1.handlers), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var handler = _c.value;\n            if (!handler.async) {\n              continue;\n            }\n            if (handlersDump.indexOf(handler) >= 0) {\n              continue;\n            }\n            _this_1.asyncHandlerChronologyExceptionRange.set(handler, {\n              \"lowerMark\": postChronologyMark,\n              \"upperMark\": chronologyMarkStartResolveTick\n            });\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n        releaseLock();\n      });\n    });\n  };\n  EvtImpl.prototype.isHandled = function (data) {\n    var _this_1 = this;\n    return !!this.getHandlers().find(function (_a) {\n      var op = _a.op;\n      return _this_1.isHandledByOp(op, data);\n    });\n  };\n  EvtImpl.prototype.getHandlers = function () {\n    return __spreadArray([], __read(this.handlers), false);\n  };\n  EvtImpl.prototype.detach = function (ctx) {\n    var e_4, _a;\n    var detachedHandlers = [];\n    try {\n      for (var _b = __values(this.getHandlers()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var handler = _c.value;\n        if (ctx !== undefined && handler.ctx !== ctx) {\n          continue;\n        }\n        var wasStillAttached = handler.detach();\n        //NOTE: It should not be possible.\n        if (!wasStillAttached) {\n          continue;\n        }\n        detachedHandlers.push(handler);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    return detachedHandlers;\n  };\n  EvtImpl.prototype.pipe = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var evtDelegate = new EvtImpl();\n    this.addHandler(__assign(__assign({}, (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, \"pipe\")), {\n      \"callback\": function (transformedData) {\n        return evtDelegate.post(transformedData);\n      }\n    }), EvtImpl.propsFormMethodNames.attach);\n    return evtDelegate;\n  };\n  EvtImpl.prototype.waitFor = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.addHandler((0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, \"waitFor\"), EvtImpl.propsFormMethodNames.waitFor).promise;\n  };\n  EvtImpl.prototype[Symbol.asyncIterator] = function () {\n    return this.iter()[Symbol.asyncIterator]();\n  };\n  EvtImpl.prototype.iter = function () {\n    var _a;\n    var _b;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var props = (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, \"waitFor\");\n    var ctx = (_b = props.ctx) !== null && _b !== void 0 ? _b : (0, Evt_newCtx_1.newCtx)();\n    var self = this;\n    return _a = {\n      ctx: ctx\n    }, _a[Symbol.asyncIterator] = function () {\n      var previousDonePostCount = ctx.evtDoneOrAborted.postCount;\n      var timerWrap = function () {\n        var timeout = props.timeout;\n        if (timeout === undefined) {\n          return undefined;\n        }\n        var setTimeoutCallback = function () {\n          var error = new EvtError_1.TimeoutEvtError(timeout);\n          ctx.abort(error);\n        };\n        var timer = setTimeout(setTimeoutCallback, timeout);\n        return {\n          timeout: timeout,\n          setTimeoutCallback: setTimeoutCallback,\n          timer: timer\n        };\n      }();\n      var evtProxy = self.pipe(ctx, props.op).pipe(function (data, registerSideEffect) {\n        if (timerWrap !== undefined) {\n          registerSideEffect(function () {\n            clearTimeout(timerWrap.timer);\n            timerWrap.timer = setTimeout(timerWrap.setTimeoutCallback, timerWrap.timeout);\n          });\n        }\n        return [data];\n      });\n      var events = [];\n      evtProxy.attach(function (event) {\n        return events.push([event]);\n      });\n      if (timerWrap !== undefined) {\n        var timer_1 = timerWrap.timer;\n        ctx.evtDoneOrAborted.attachOnce(function (event) {\n          return event.type === \"DONE\";\n        }, function () {\n          return clearTimeout(timer_1);\n        });\n      }\n      return {\n        next: function () {\n          return __awaiter(this, void 0, void 0, function () {\n            var eventWrap, dEventWrap_1, ctx2_1, out;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  eventWrap = events.shift();\n                  if (!(eventWrap === undefined)) return [3 /*break*/, 2];\n                  dEventWrap_1 = new Deferred_1.Deferred();\n                  if (previousDonePostCount < ctx.evtDoneOrAborted.postCount) {\n                    return [2 /*return*/, {\n                      \"done\": true\n                    }];\n                  }\n                  ctx2_1 = (0, Evt_newCtx_1.newCtx)();\n                  ctx.evtDoneOrAborted.attachOnce(ctx2_1, function () {\n                    return dEventWrap_1.resolve(undefined);\n                  });\n                  evtProxy.attachOnceExtract(ctx2_1, function (event) {\n                    ctx2_1.done();\n                    dEventWrap_1.resolve([event]);\n                  });\n                  return [4 /*yield*/, dEventWrap_1.pr];\n                case 1:\n                  eventWrap = _a.sent();\n                  if (eventWrap === undefined) {\n                    return [2 /*return*/, {\n                      \"done\": true\n                    }];\n                  }\n                  _a.label = 2;\n                case 2:\n                  out = {\n                    \"done\": false,\n                    \"value\": eventWrap[0]\n                  };\n                  return [2 /*return*/, out];\n              }\n            });\n          });\n        },\n        return: function () {\n          self.detach(ctx);\n          return {\n            \"done\": true\n          };\n        }\n      };\n    }, _a;\n  };\n  EvtImpl.prototype.$attach = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attach.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attach = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attach\");\n  };\n  EvtImpl.prototype.$attachOnce = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attachOnce.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attachOnce = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attachOnce\");\n  };\n  EvtImpl.prototype.$attachExtract = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attachExtract.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attachExtract = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attachExtract\");\n  };\n  EvtImpl.prototype.$attachPrepend = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attachPrepend.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attachPrepend = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attachPrepend\");\n  };\n  EvtImpl.prototype.$attachOncePrepend = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attachOncePrepend.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attachOncePrepend = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attachOncePrepend\");\n  };\n  EvtImpl.prototype.$attachOnceExtract = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.attachOnceExtract.apply(this, __spreadArray([], __read(args), false));\n  };\n  EvtImpl.prototype.attachOnceExtract = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return this.__attachX(args, \"attachOnceExtract\");\n  };\n  EvtImpl.prototype.__attachX = function (args, methodName) {\n    var propsFromArgs = (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, \"attach*\");\n    var handler = this.addHandler(propsFromArgs, EvtImpl.propsFormMethodNames[methodName]);\n    return propsFromArgs.timeout === undefined ? this : handler.promise;\n  };\n  EvtImpl.prototype.postAsyncOnceHandled = function (data) {\n    var _this_1 = this;\n    if (this.isHandled(data)) {\n      return this.post(data);\n    }\n    var d = new Deferred_1.Deferred();\n    this.evtAttach.attachOnce(function (_a) {\n      var op = _a.op;\n      return _this_1.isHandledByOp(op, data);\n    }, function () {\n      return Promise.resolve().then(function () {\n        return d.resolve(_this_1.post(data));\n      });\n    });\n    return d.pr;\n  };\n  EvtImpl.prototype.postOrPostAndWait = function (data, wait) {\n    var _this_1 = this;\n    this.trace(data);\n    (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(this, \"postCount\", this.postCount + 1);\n    //NOTE: Must be before postSync.\n    var postChronologyMark = this.getChronologyMark();\n    var _a = __read(this.postSync(data), 2),\n      isExtracted = _a[0],\n      prAllHandlerCallbacksResolved = _a[1];\n    var getReturnValue = wait ? function () {\n      return prAllHandlerCallbacksResolved;\n    } : function () {\n      return _this_1.postCount;\n    };\n    if (isExtracted) {\n      return getReturnValue();\n    }\n    if (this.postAsync === undefined) {\n      if (this.asyncHandlerCount === 0) {\n        return getReturnValue();\n      }\n      this.postAsync = this.postAsyncFactory();\n    }\n    this.postAsync(data, postChronologyMark);\n    return getReturnValue();\n  };\n  EvtImpl.prototype.post = function (data) {\n    return this.postOrPostAndWait(data, false);\n  };\n  EvtImpl.prototype.postAndWait = function (data) {\n    return this.postOrPostAndWait(data, true);\n  };\n  EvtImpl.create = Evt_create_1.create;\n  EvtImpl.newCtx = Evt_newCtx_1.newCtx;\n  EvtImpl.merge = Evt_merge_1.merge;\n  EvtImpl.from = Evt_from_1.from;\n  EvtImpl.getCtx = (0, Evt_getCtx_1.getCtxFactory)();\n  EvtImpl.loosenType = Evt_loosenType_1.loosenType;\n  EvtImpl.factorize = Evt_factorize_1.factorize;\n  EvtImpl.asPostable = Evt_asPostable_1.asPostable;\n  EvtImpl.asyncPipe = Evt_asyncPipe_1.asyncPipe;\n  EvtImpl.asNonPostable = Evt_asNonPostable_1.asNonPostable;\n  EvtImpl.__defaultMaxHandlers = 25;\n  EvtImpl.propsFormMethodNames = {\n    \"waitFor\": {\n      \"async\": true,\n      \"extract\": false,\n      \"once\": true,\n      \"prepend\": false\n    },\n    \"attach\": {\n      \"async\": false,\n      \"extract\": false,\n      \"once\": false,\n      \"prepend\": false\n    },\n    \"attachExtract\": {\n      \"async\": false,\n      \"extract\": true,\n      \"once\": false,\n      \"prepend\": true\n    },\n    \"attachPrepend\": {\n      \"async\": false,\n      \"extract\": false,\n      \"once\": false,\n      \"prepend\": true\n    },\n    \"attachOnce\": {\n      \"async\": false,\n      \"extract\": false,\n      \"once\": true,\n      \"prepend\": false\n    },\n    \"attachOncePrepend\": {\n      \"async\": false,\n      \"extract\": false,\n      \"once\": true,\n      \"prepend\": true\n    },\n    \"attachOnceExtract\": {\n      \"async\": false,\n      \"extract\": true,\n      \"once\": true,\n      \"prepend\": true\n    }\n  };\n  return EvtImpl;\n}();\n/**\n * Can be seen as a protected method that can be\n * optionally be implemented by class extending Evt.\n *\n * Should only be accessible from within the module.\n * Basically it is for allowing StatefulEvt to execute\n * the callback on attach.\n */\nexports.onAddHandlerByEvt = new WeakMap_1.Polyfill();\nexports.Evt = EvtImpl;\ntry {\n  (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(exports.Evt, \"name\", \"Evt\");\n} catch (_a) {}\nimportProxy_1.importProxy.Evt = exports.Evt;","map":{"version":3,"names":["require","Map_1","WeakMap_1","importProxy_1","Evt_create_1","Evt_getCtx_1","Evt_factorize_1","Evt_merge_1","Evt_from_1","Evt_asPostable_1","Evt_asyncPipe_1","Evt_asNonPostable_1","Evt_parsePropsFromArgs_1","Evt_newCtx_1","LazyEvt_1","runExclusive","__importStar","overwriteReadonlyProp_1","typeGuard_1","Deferred_1","Evt_loosenType_1","safeSetTimeout_1","isPromiseLike_1","EvtError_1","nsCtxLike","convertOperatorToStatelessFLambda_1","runSideEffect","sideEffect","CtxLikeAsValue","CtxLike","EvtImpl","lazyEvtAttach","LazyEvt","lazyEvtDetach","__maxHandlers","undefined","postCount","traceId","handlers","handlerTriggers","Polyfill","__currentChronologyMark","asyncHandlerCount","setDefaultMaxHandlers","n","__defaultMaxHandlers","isFinite","prototype","toStateful","p1","p2","isP1Ctx","match","initialValue","ctx","out","importProxy","StatefulEvt","callback","data","post","attach","Object","defineProperty","get","evt","setMaxHandlers","enableTrace","params","id","formatter","log","traceFormatter","JSON","stringify","_a","concat","inputs","_i","arguments","length","console","apply","__spreadArray","__read","disableTrace","_b","_d","_c","getInvocableOp","op","invocableOp","invocableOpByOp","Error","join","getChronologyMark","detachHandler","handler","wTimer","rejectPr","index","indexOf","typeGuard","zz__removeHandler","splice","async","delete","safeClearTimeout","DetachedEvtError","triggerHandler","resolvePr","opResult","once","detach","transformedData","prOrValue","call","isPromiseLike","addHandler","propsFromArgs","propsFromMethodName","_this_1","set","convertOperatorToStatelessFλ","d","Deferred","__assign","reject","pr","timeout","safeSetTimeout","TimeoutEvtError","handlerTrigger","isPending","resolve","asyncHandlerChronologyMark","prepend","i","extract","push","checkForPotentialMemoryLeak","zz__addHandler","exports","onAddHandlerByEvt","has","maxHandlers","message","map","getHandlers","matchAll","toString","obj","keys","key","forEach","str","Array","from","warn","isHandledByOp","hasSideEffect","trace","isExtracted","find","handlerCount","filter","postSync","prAllHandlerCallbacksResolved","getReturnValue","Promise","all","then","__values","next","done","value","prOrUndefined","postAsyncFactory","buildMethodCb","postChronologyMark","releaseLock","promises","chronologyMarkStartResolveTick","shouldCallHandlerTrigger","handlerMark","exceptionRange","asyncHandlerChronologyExceptionRange","lowerMark","upperMark","promise","catch","handlersDump","isHandled","detachedHandlers","wasStillAttached","pipe","args","evtDelegate","parsePropsFromArgs","propsFormMethodNames","waitFor","Symbol","asyncIterator","iter","props","newCtx","self","previousDonePostCount","evtDoneOrAborted","timerWrap","setTimeoutCallback","error","abort","timer","setTimeout","evtProxy","registerSideEffect","clearTimeout","events","event","timer_1","attachOnce","type","eventWrap","shift","dEventWrap_1","ctx2_1","attachOnceExtract","sent","return","$attach","__attachX","$attachOnce","$attachExtract","attachExtract","$attachPrepend","attachPrepend","$attachOncePrepend","attachOncePrepend","$attachOnceExtract","methodName","postAsyncOnceHandled","evtAttach","postOrPostAndWait","wait","overwriteReadonlyProp","postAsync","postAndWait","create","merge","getCtx","getCtxFactory","loosenType","factorize","asPostable","asyncPipe","asNonPostable","Evt"],"sources":["C:\\Users\\prana\\AppData\\Local\\Yarn\\Berry\\cache\\evt-npm-2.5.3-c2ac0365d2-10c0.zip\\node_modules\\evt\\src\\lib\\Evt.ts"],"sourcesContent":["// @denoify-line-ignore\nimport \"minimal-polyfills/Array.prototype.find\";\n// @denoify-line-ignore\nimport { Polyfill as Map } from \"minimal-polyfills/Map\";\n// @denoify-line-ignore\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport type { LightMap } from \"../tools/minimal-polyfills/LightMap\";\nimport { importProxy } from \"./importProxy\";\nimport { create } from \"./Evt.create\";\nimport { getCtxFactory } from \"./Evt.getCtx\";\nimport { factorize } from \"./Evt.factorize\";\nimport { merge } from \"./Evt.merge\";\nimport { from } from \"./Evt.from\";\nimport { asPostable } from \"./Evt.asPostable\";\nimport { asyncPipe } from \"./Evt.asyncPipe\";\nimport { asNonPostable } from \"./Evt.asNonPostable\";\nimport { parsePropsFromArgs, matchAll } from \"./Evt.parsePropsFromArgs\";\nimport { newCtx } from \"./Evt.newCtx\";\nimport { LazyEvt } from \"./LazyEvt\";\nimport * as runExclusive from \"run-exclusive\";\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport { Deferred } from \"../tools/Deferred\";\nimport { loosenType } from \"./Evt.loosenType\";\nimport { safeClearTimeout, safeSetTimeout, Timer } from \"../tools/safeSetTimeout\";\nimport { isPromiseLike } from \"tsafe/isPromiseLike\";\nimport { DetachedEvtError, TimeoutEvtError } from \"./types/EvtError\";\nimport * as nsCtxLike from \"./types/interfaces/CtxLike\";\nimport type { Handler, Operator, NonPostableEvt, StatefulEvt, NonPostableEvtLike, CtxLike } from \"./types\";\nimport { convertOperatorToStatelessFλ } from \"./util/convertOperatorToStatelessFLambda\";\nimport type { AsyncIterableEvt } from \"./types/AsyncIterableEvt\";\n\nconst runSideEffect = (sideEffect: () => void) => sideEffect();\n\n// NOTE: For compat with --no-check \n// https://github.com/asos-craigmorten/opine/issues/97#issuecomment-751806014\nconst { CtxLike: CtxLikeAsValue } = nsCtxLike;\n\n/** https://docs.evt.land/api/evt */\nexport type Evt<T> = import(\"./types/interfaces/Evt\").Evt<T>;\n\n\nclass EvtImpl<T> implements Evt<T> {\n\n    static readonly create = create;\n\n    static readonly newCtx = newCtx;\n\n    static readonly merge = merge;\n\n    static readonly from = from;\n\n    static readonly getCtx = getCtxFactory();\n\n    static readonly loosenType = loosenType;\n\n    static readonly factorize = factorize;\n\n    static readonly asPostable = asPostable;\n\n    static readonly asyncPipe = asyncPipe;\n\n    static readonly asNonPostable = asNonPostable;\n\n    private static __defaultMaxHandlers = 25;\n\n    static setDefaultMaxHandlers(n: number): void {\n        this.__defaultMaxHandlers = isFinite(n) ? n : 0;\n    }\n\n    toStateful(p1: any, p2?: CtxLike): StatefulEvt<any> {\n\n        const isP1Ctx = CtxLikeAsValue.match(p1);\n\n        const initialValue: any = isP1Ctx ? undefined : p1;\n        const ctx = p2 || (isP1Ctx ? p1 : undefined);\n\n        const out = new importProxy.StatefulEvt<any>(initialValue);\n\n        const callback = (data: T) => out.post(data);\n\n        if (!!ctx) {\n            this.attach(ctx, callback);\n        } else {\n            this.attach(callback);\n        }\n\n        return out;\n\n    }\n\n    get evtAttach(): Evt<Handler<T, any>> {\n        return this.lazyEvtAttach.evt;\n    }\n\n    get evtDetach(): Evt<Handler<T, any>> {\n        return this.lazyEvtDetach.evt;\n    }\n\n    private readonly lazyEvtAttach = new LazyEvt<Handler<T, any>>();\n    private readonly lazyEvtDetach = new LazyEvt<Handler<T, any>>();\n\n\n    private __maxHandlers: undefined | number = undefined;\n\n    setMaxHandlers(n: number): this {\n        this.__maxHandlers = isFinite(n) ? n : 0;\n        return this;\n    }\n\n    readonly postCount: number = 0;\n\n    private traceId: string | null = null;\n    private traceFormatter!: (data: T) => string;\n    private log!: Exclude<Parameters<NonPostableEvt<any>[\"enableTrace\"]>[0][\"log\"], false>;\n\n    enableTrace(\n        params: {\n            id: string,\n            formatter?: (data: T) => string,\n            log?: ((message?: any, ...optionalParams: any[]) => void) | false\n        }\n        //NOTE: Not typeof console.log as we don't want to expose types from node\n    ): void {\n\n        const { id, formatter, log } = params;\n\n        this.traceId = id;\n\n        this.traceFormatter = formatter || (\n            data => {\n                try {\n                    return JSON.stringify(data, null, 2);\n                } catch {\n                    return `${data}`;\n                }\n            }\n        );\n\n        this.log =\n            log === undefined ?\n                ((...inputs) => console.log(...inputs)) :\n                log === false ? undefined : log\n            ;\n\n    }\n\n    disableTrace(): this {\n        this.traceId = null;\n        return this;\n    }\n\n    private readonly handlers: Handler<T, any>[] = [];\n\n    private readonly handlerTriggers: LightMap<\n        Handler<T, any>,\n        (opResult: readonly [any]) => PromiseLike<void> | undefined\n    > = new Map();\n\n\n    //NOTE: An async handler ( attached with waitFor ) is only eligible to handle a post if the post\n    //occurred after the handler was set. We don't want to waitFor event from the past.\n    //private readonly asyncHandlerChronologyMark = new WeakMap<ImplicitParams.Async, number>();\n    private get asyncHandlerChronologyMark(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        number\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyMark\"] ??= new WeakMap<any, any>();\n    }\n\n    //NOTE: There is an exception to the above rule, we want to allow async waitFor loop \n    //do so we have to handle the case where multiple event would be posted synchronously.\n    private get asyncHandlerChronologyExceptionRange(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        { lowerMark: number; upperMark: number; }\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyExceptionRange\"] ??= new WeakMap<any, any>();\n    }\n\n\n    private get invocableOpByOp(): WeakMap<\n        Operator<T, any>,\n        Operator.fλ.Stateless<T, any>\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"invocableOpByOp\"] ??= new WeakMap<any, any>();\n    }\n\n    getInvocableOp<U>(op: Operator<T, U>): Operator.fλ.Stateless<T, U> {\n\n        const invocableOp = this.invocableOpByOp.get(op);\n\n        if (invocableOp === undefined) {\n            throw new Error([\n                \"Provided operator isn't the operator of any handler\",\n                \"currently attached to the Evt instance\"\n            ].join(\" \"));\n        }\n\n        return invocableOp;\n\n    }\n\n    /*\n    NOTE: Used as Date.now() would be used to compare if an event is anterior \n    or posterior to an other. We don't use Date.now() because two call within\n    less than a ms will return the same value unlike this function.\n    */\n    private __currentChronologyMark = 0;\n    private getChronologyMark() {\n        return this.__currentChronologyMark++;\n    }\n\n\n    private asyncHandlerCount: number = 0;\n\n    private detachHandler(\n        handler: Handler<T, any>,\n        wTimer: [Timer | undefined],\n        rejectPr: (error: DetachedEvtError) => void\n    ) {\n\n        const index = this.handlers.indexOf(handler);\n\n        if (index < 0) {\n            return false;\n        }\n\n        if (typeGuard<Handler<T, any, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__removeHandler(handler);\n        }\n\n\n        this.handlers.splice(index, 1);\n\n        if (handler.async) {\n            this.asyncHandlerCount--;\n        }\n\n        this.handlerTriggers.delete(handler);\n\n        if (wTimer[0] !== undefined) {\n\n            safeClearTimeout(wTimer[0]);\n\n            rejectPr(new DetachedEvtError());\n\n        }\n\n        this.lazyEvtDetach.post(handler);\n\n        return true;\n\n    }\n\n\n    private triggerHandler<U>(\n        handler: Handler<T, U>,\n        wTimer: [Timer | undefined],\n        resolvePr: ((transformedData: any) => void) | undefined,\n        opResult: readonly [U] //TODO: Or readonly [ any ] ?? \n    ): PromiseLike<void> | undefined {\n\n        const { callback, once } = handler;\n\n        if (wTimer[0] !== undefined) {\n            safeClearTimeout(wTimer[0]);\n            wTimer[0] = undefined;\n        }\n\n        if (once) {\n            handler.detach();\n        }\n\n        const [transformedData] = opResult;\n\n        const prOrValue = callback?.call(\n            this,\n            transformedData\n        );\n\n        resolvePr?.(transformedData);\n\n        return isPromiseLike(prOrValue) ? prOrValue : undefined;\n\n    }\n\n    private addHandler<U>(\n        propsFromArgs: Handler.PropsFromArgs<T, U>,\n        propsFromMethodName: Handler.PropsFromMethodName\n    ): Handler<T, U> {\n\n        this.invocableOpByOp.set(\n            propsFromArgs.op,\n            convertOperatorToStatelessFλ(propsFromArgs.op)\n        );\n\n        const d = new Deferred<U>();\n\n        const wTimer: [Timer | undefined] = [undefined];\n\n        const handler: Handler<T, U> = {\n            ...propsFromArgs,\n            ...propsFromMethodName,\n            \"detach\": () => this.detachHandler(handler, wTimer, d.reject),\n            \"promise\": d.pr\n        };\n\n        if (typeof handler.timeout === \"number\") {\n\n            wTimer[0] = safeSetTimeout(() => {\n\n                wTimer[0] = undefined;\n\n                handler.detach();\n\n                d.reject(new TimeoutEvtError(handler.timeout!));\n\n            }, handler.timeout);\n\n        }\n\n        const handlerTrigger: (opResult: readonly [U]) => PromiseLike<void> | undefined\n            = opResult => this.triggerHandler(\n                handler,\n                wTimer,\n                d.isPending ? d.resolve : undefined,\n                opResult\n            );\n\n        this.handlerTriggers.set(\n            handler,\n            handlerTrigger\n        );\n\n        if (handler.async) {\n\n            this.asyncHandlerChronologyMark.set(\n                handler,\n                this.getChronologyMark()\n            );\n\n        }\n\n        if (handler.prepend) {\n\n            let i: number;\n\n            for (i = 0; i < this.handlers.length; i++) {\n\n                if (this.handlers[i].extract) {\n                    continue;\n                }\n\n                break;\n\n            }\n\n            this.handlers.splice(i, 0, handler);\n\n        } else {\n\n            this.handlers.push(handler);\n\n        }\n\n        if (handler.async) {\n            this.asyncHandlerCount++;\n        }\n\n        this.checkForPotentialMemoryLeak();\n\n        if (typeGuard<Handler<T, U, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__addHandler(handler, this);\n        }\n\n        onAddHandlerByEvt.get(this)?.(handler, handlerTrigger);\n\n        //NOTE: Can happen for example if this is a StatefulEvt \n        //and the handler is \"once\" and the matcher match the state \n        //We don't want to post an attach if the handler is already detached.\n        if (this.handlerTriggers.has(handler)) {\n\n            this.lazyEvtAttach.post(handler);\n\n        }\n\n        return handler;\n\n    }\n\n\n\n    private checkForPotentialMemoryLeak(): void {\n\n        const maxHandlers = this.__maxHandlers !== undefined ?\n            this.__maxHandlers :\n            EvtImpl.__defaultMaxHandlers\n            ;\n\n\n        if (\n            maxHandlers === 0 ||\n            this.handlers.length % (maxHandlers + 1) !== 0) {\n            return;\n        }\n\n        let message = [\n            `MaxHandlersExceededWarning: Possible Evt memory leak detected.`,\n            `${this.handlers.length} handlers attached${this.traceId ? ` to \"${this.traceId}\"` : \"\"}.\\n`,\n            `Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\\n`,\n            `Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to ${EvtImpl.__defaultMaxHandlers}.\\n`,\n        ].join(\"\");\n\n        const map = new Map<string, number>();\n\n        this.getHandlers()\n            .map(({ ctx, async, once, prepend, extract, op, callback }) => ({\n                \"hasCtx\": !!ctx,\n                once,\n                prepend,\n                extract,\n                \"isWaitFor\": async,\n                ...(op === matchAll ? {} : { \"op\": op.toString() }),\n                ...(!callback ? {} : { \"callback\": callback.toString() })\n            }))\n            .map(obj =>\n                \"{\\n\" + Object.keys(obj)\n                    .map(key => `  ${key}: ${(obj as any)[key]}`)\n                    .join(\",\\n\") + \"\\n}\"\n            )\n            .forEach(str => map.set(str, (map.has(str) ? map.get(str)! : 0) + 1))\n            ;\n\n        message += \"\\n\" + Array.from(map.keys())\n            .map(str => `${map.get(str)} handler${map.get(str) === 1 ? \"\" : \"s\"} like:\\n${str}`)\n            .join(\"\\n\") + \"\\n\";\n\n        if (this.traceId === null) {\n\n            message += \"\\n\" + [\n                `To validate the identify of the Evt instance that is triggering this warning you can call`,\n                `Evt.prototype.enableTrace({ \"id\": \"My evt id\", \"log\": false }) on the Evt that you suspect.\\n`\n            ].join(\" \");\n\n        }\n\n        try {\n            console.warn(message);\n        } catch {\n        }\n\n    }\n\n    isHandledByOp<U>(op: Operator<T, U>, data: T): boolean {\n\n        let hasSideEffect = false;\n\n        let invocableOp: Operator.fλ.Stateless<T, U>;\n\n        try {\n\n            invocableOp = this.getInvocableOp(op);\n\n        } catch {\n\n            return false;\n\n        }\n\n        const opResult = invocableOp(\n            data,\n            () => hasSideEffect = true\n        );\n\n        return opResult !== null || hasSideEffect;\n\n    }\n\n\n    private trace(data: T) {\n\n        if (this.traceId === null) {\n            return;\n        }\n\n        let message = `(${this.traceId}) `;\n\n        const isExtracted = !!this.handlers.find(\n            ({ extract, op }) => (\n                extract &&\n                this.isHandledByOp(op, data)\n            )\n        );\n\n        if (isExtracted) {\n\n            message += \"extracted \";\n\n        } else {\n\n            const handlerCount = this.handlers\n                .filter(\n                    ({ extract, op }) => !extract &&\n                        this.isHandledByOp(op, data)\n                )\n                .length;\n\n            message += `${handlerCount} handler${(handlerCount > 1) ? \"s\" : \"\"}, `;\n\n        }\n\n        this.log?.(message + this.traceFormatter(data));\n\n    }\n\n    /** Return [ isExtracted, prAllHandlerCallbacksResolved ] */\n    private postSync(data: T): readonly [boolean, Promise<void>] {\n\n        const prAllHandlerCallbacksResolved: PromiseLike<void>[] = [];\n\n        const getReturnValue = (isExtracted: boolean) => [\n            isExtracted,\n            Promise.all(prAllHandlerCallbacksResolved).then(() => { })\n        ] as const;\n\n\n        for (const handler of [...this.handlers]) {\n\n            const { async, op, extract } = handler;\n\n            if (async) {\n                continue;\n            }\n\n            //NOTE: If detached while executing the operator\n            //we still want to trigger the handler.\n            const handlerTrigger = this.handlerTriggers.get(handler);\n\n            const opResult = this.getInvocableOp(op)(\n                data,\n                runSideEffect\n            );\n\n            if (opResult === null) {\n                continue;\n            }\n\n            //NOTE: Possible if detached while in the loop.\n            if (!handlerTrigger) {\n                continue;\n            }\n\n            const prOrUndefined = handlerTrigger(opResult);\n\n            if (prOrUndefined !== undefined) {\n                prAllHandlerCallbacksResolved.push(prOrUndefined);\n            }\n\n            if (extract) {\n                return getReturnValue(true);\n            }\n\n        }\n\n        return getReturnValue(false);\n\n    }\n\n    private postAsyncFactory() {\n        return runExclusive.buildMethodCb(\n            (data: T, postChronologyMark: number, releaseLock?) => {\n\n                if (this.asyncHandlerCount === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const promises: Promise<void>[] = [];\n\n                let chronologyMarkStartResolveTick: number;\n\n                //NOTE: Must be before handlerTrigger call.\n                Promise.resolve().then(\n                    () => chronologyMarkStartResolveTick = this.getChronologyMark()\n                );\n\n\n                for (const handler of [...this.handlers]) {\n\n                    if (!handler.async) {\n                        continue;\n                    }\n\n                    const opResult = this.getInvocableOp(handler.op)(\n                        data,\n                        runSideEffect\n                    );\n\n                    if (opResult === null) {\n                        continue;\n                    }\n\n                    const handlerTrigger = this.handlerTriggers.get(handler);\n\n                    if (!handlerTrigger) {\n                        continue;\n                    }\n\n                    const shouldCallHandlerTrigger = (() => {\n\n                        const handlerMark = this.asyncHandlerChronologyMark.get(handler)!;\n\n                        if (postChronologyMark > handlerMark) {\n                            return true;\n                        }\n\n                        const exceptionRange = this.asyncHandlerChronologyExceptionRange.get(handler);\n\n                        return (\n                            exceptionRange !== undefined &&\n                            exceptionRange.lowerMark < postChronologyMark &&\n                            postChronologyMark < exceptionRange.upperMark &&\n                            handlerMark > exceptionRange.upperMark\n                        );\n\n                    })();\n\n                    if (!shouldCallHandlerTrigger) {\n                        continue;\n                    }\n\n                    promises.push(\n                        new Promise<void>(\n                            resolve => handler.promise\n                                .then(() => resolve())\n                                .catch(() => resolve())\n                        )\n                    );\n\n                    handlerTrigger(opResult);\n\n\n                }\n\n                if (promises.length === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const handlersDump = [...this.handlers];\n\n                Promise.all(promises).then(() => {\n\n                    for (const handler of this.handlers) {\n\n                        if (!handler.async) {\n                            continue;\n                        }\n\n                        if (handlersDump.indexOf(handler) >= 0) {\n                            continue;\n                        }\n\n                        this.asyncHandlerChronologyExceptionRange.set(\n                            handler,\n                            {\n                                \"lowerMark\": postChronologyMark,\n                                \"upperMark\": chronologyMarkStartResolveTick\n                            }\n                        );\n\n                    }\n\n                    releaseLock();\n\n                });\n\n            }\n        );\n    }\n\n    declare private postAsync: (\n        (\n            data: T,\n            postChronologyMark: number\n        ) => void\n    ) | undefined;\n\n    private static readonly propsFormMethodNames: Record<\n        \"waitFor\" | \"attach\" | \"attachExtract\" | \"attachPrepend\" | \"attachOnce\" |\n        \"attachOncePrepend\" | \"attachOnceExtract\"\n        ,\n        Handler.PropsFromMethodName\n    > = {\n            \"waitFor\": { \"async\": true, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attach\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": false },\n            \"attachExtract\": { \"async\": false, \"extract\": true, \"once\": false, \"prepend\": true },\n            \"attachPrepend\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": true },\n            \"attachOnce\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attachOncePrepend\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": true },\n            \"attachOnceExtract\": { \"async\": false, \"extract\": true, \"once\": true, \"prepend\": true }\n        };\n\n    isHandled(data: T): boolean {\n        return !!this.getHandlers()\n            .find(({ op }) => this.isHandledByOp(op, data))\n            ;\n    }\n\n    getHandlers(): Handler<T, any>[] {\n        return [...this.handlers];\n    }\n\n    detach(ctx?: CtxLike<any>): Handler<T, any, any>[] {\n\n        const detachedHandlers: Handler<T, any>[] = [];\n\n        for (const handler of this.getHandlers()) {\n\n            if (ctx !== undefined && handler.ctx !== ctx) {\n                continue;\n            }\n\n            const wasStillAttached = handler.detach();\n\n            //NOTE: It should not be possible.\n            if (!wasStillAttached) {\n                continue;\n            }\n\n            detachedHandlers.push(handler);\n\n        }\n\n        return detachedHandlers;\n\n    }\n\n    pipe(...args: any[]): Evt<any> {\n\n        const evtDelegate = new EvtImpl<any>();\n\n        this.addHandler(\n            {\n                ...parsePropsFromArgs<T>(args, \"pipe\"),\n                \"callback\": (transformedData: any) => evtDelegate.post(transformedData)\n            },\n            EvtImpl.propsFormMethodNames.attach\n        );\n\n        return evtDelegate;\n\n    }\n\n    waitFor(...args: any[]): Promise<any> {\n        return this.addHandler(\n            parsePropsFromArgs<T>(args, \"waitFor\"),\n            EvtImpl.propsFormMethodNames.waitFor\n        ).promise;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this.iter()[Symbol.asyncIterator]();\n    }\n\n    iter(...args: any[]): AsyncIterableEvt<any, any> {\n\n        const props = parsePropsFromArgs<T>(args, \"waitFor\");\n\n        const ctx = (props.ctx ?? newCtx()) as ReturnType<typeof newCtx>;\n\n        const self = this;\n\n        return {\n            ctx,\n            [Symbol.asyncIterator]() {\n\n                const previousDonePostCount = ctx.evtDoneOrAborted.postCount;\n\n                const timerWrap = (() => {\n\n                    const { timeout } = props;\n\n                    if (timeout === undefined) {\n                        return undefined;\n                    }\n\n                    const setTimeoutCallback = () => {\n                        const error = new TimeoutEvtError(timeout);\n                        ctx.abort(error);\n                    };\n\n                    const timer = setTimeout(setTimeoutCallback, timeout);\n\n                    return { timeout, setTimeoutCallback, timer };\n\n                })();\n\n                const evtProxy = self\n                    .pipe(ctx, props.op)\n                    .pipe((data, registerSideEffect) => {\n\n                        if (timerWrap !== undefined) {\n\n                            registerSideEffect(() => {\n\n                                clearTimeout(timerWrap.timer);\n\n                                timerWrap.timer = setTimeout(timerWrap.setTimeoutCallback, timerWrap.timeout);\n                            });\n\n                        }\n\n                        return [data];\n                    });\n\n                const events: [T][] = [];\n\n                evtProxy.attach(event => events.push([event]));\n\n                if (timerWrap !== undefined) {\n\n                    const { timer } = timerWrap;\n\n                    ctx.evtDoneOrAborted.attachOnce(\n                        event => event.type === \"DONE\",\n                        () => clearTimeout(timer)\n                    );\n\n                }\n\n                return {\n                    async next() {\n\n                        let eventWrap = events.shift();\n\n                        if (eventWrap === undefined) {\n\n                            const dEventWrap = new Deferred<[T] | undefined>();\n\n                            if (previousDonePostCount < ctx.evtDoneOrAborted.postCount) {\n                                return { \"done\": true };\n                            }\n\n                            const ctx2 = newCtx();\n\n                            ctx.evtDoneOrAborted.attachOnce(\n                                ctx2,\n                                () => dEventWrap.resolve(undefined)\n                            );\n\n                            evtProxy.attachOnceExtract(ctx2, event => {\n                                ctx2.done();\n                                dEventWrap.resolve([event])\n                            });\n\n                            eventWrap = await dEventWrap.pr;\n\n                            if (eventWrap === undefined) {\n                                return { \"done\": true };\n                            }\n\n                        }\n\n                        const out = { \"done\": false, \"value\": eventWrap[0] } as any;\n\n                        return out;\n\n                    },\n                    return() {\n\n                        self.detach(ctx);\n\n                        return { \"done\": true } as any;\n                    },\n                };\n            }\n\n        };\n\n\n    }\n\n\n\n\n    $attach(...args: any[]) {\n        return this.attach(...args);\n    }\n\n    attach(...args: any[]) {\n        return this.__attachX(args, \"attach\");\n    }\n\n    $attachOnce(...args: any[]) {\n        return this.attachOnce(...args);\n    }\n\n    attachOnce(...args: any[]) {\n        return this.__attachX(args, \"attachOnce\");\n    }\n\n    $attachExtract(...args: any[]) {\n        return this.attachExtract(...args);\n    }\n\n    attachExtract(...args: any[]) {\n        return this.__attachX(args, \"attachExtract\");\n    }\n\n    $attachPrepend(...args: any[]) {\n        return (this.attachPrepend as any)(...args);\n    }\n\n    attachPrepend(...args: any[]) {\n        return this.__attachX(args, \"attachPrepend\");\n    }\n\n    $attachOncePrepend(...args: any[]) {\n        return this.attachOncePrepend(...args);\n    }\n\n    attachOncePrepend(...args: any[]) {\n        return this.__attachX(args, \"attachOncePrepend\");\n    }\n\n    $attachOnceExtract(...args: any[]) {\n        return this.attachOnceExtract(...args);\n    }\n\n    attachOnceExtract(...args: any[]) {\n        return this.__attachX(args, \"attachOnceExtract\");\n    }\n\n    private __attachX(\n        args: any[],\n        methodName: keyof typeof EvtImpl.propsFormMethodNames\n    ): any {\n\n        const propsFromArgs = parsePropsFromArgs<T>(args, \"attach*\");\n\n        const handler = this.addHandler(\n            propsFromArgs,\n            EvtImpl.propsFormMethodNames[methodName]\n        );\n\n        return propsFromArgs.timeout === undefined ?\n            this :\n            handler.promise\n            ;\n\n    }\n\n    postAsyncOnceHandled(data: T): number | Promise<number> {\n\n        if (this.isHandled(data)) {\n            return this.post(data);\n        }\n\n        const d = new Deferred<number>();\n\n        this.evtAttach.attachOnce(\n            ({ op }) => this.isHandledByOp(op, data),\n            () => Promise.resolve().then(() => d.resolve(this.post(data)))\n        );\n\n        return d.pr;\n\n    }\n\n    private postOrPostAndWait(data: T, wait: false): number;\n    private postOrPostAndWait(data: T, wait: true): Promise<void>;\n    private postOrPostAndWait(data: T, wait: boolean): number | Promise<void> {\n\n        this.trace(data);\n\n        overwriteReadonlyProp(this, \"postCount\", this.postCount + 1);\n\n        //NOTE: Must be before postSync.\n        const postChronologyMark = this.getChronologyMark();\n\n        const [isExtracted, prAllHandlerCallbacksResolved] = this.postSync(data);\n\n        const getReturnValue = wait ?\n            () => prAllHandlerCallbacksResolved :\n            () => this.postCount;\n\n        if (isExtracted) {\n            return getReturnValue();\n        }\n\n        if (this.postAsync === undefined) {\n\n            if (this.asyncHandlerCount === 0) {\n                return getReturnValue();\n            }\n\n            this.postAsync = this.postAsyncFactory();\n\n        }\n\n        this.postAsync(data, postChronologyMark);\n\n        return getReturnValue();\n\n    }\n\n    post(data: T) {\n        return this.postOrPostAndWait(data, false);\n    }\n\n    postAndWait(data: T) {\n        return this.postOrPostAndWait(data, true);\n    }\n\n}\n\n/** \n * Can be seen as a protected method that can be \n * optionally be implemented by class extending Evt.\n * \n * Should only be accessible from within the module.\n * Basically it is for allowing StatefulEvt to execute\n * the callback on attach.\n */\nexport const onAddHandlerByEvt = new WeakMap<\n    NonPostableEvtLike<any>,\n    (\n        handler: Handler<any, any>,\n        handlerTrigger: (opResult: readonly [any]) => PromiseLike<void> | undefined\n    ) => void>();\n\n\nexport const Evt: {\n    new <T>(): Evt<T>;\n    readonly prototype: Evt<any>;\n\n    readonly create: typeof create;\n\n    readonly newCtx: typeof newCtx;\n\n    readonly merge: typeof merge;\n\n    readonly from: typeof from;\n\n    readonly getCtx: ReturnType<typeof getCtxFactory>;\n\n    readonly loosenType: typeof loosenType;\n\n    readonly factorize: typeof factorize;\n\n    readonly asPostable: typeof asPostable;\n\n    readonly asyncPipe: typeof asyncPipe;\n\n    readonly asNonPostable: typeof asNonPostable;\n\n    /** https://docs.evt.land/api/evt/setdefaultmaxhandlers */\n    setDefaultMaxHandlers(n: number): void;\n\n} = EvtImpl;\n\ntry { overwriteReadonlyProp(Evt as any, \"name\", \"Evt\"); } catch { }\n\nimportProxy.Evt = Evt;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}